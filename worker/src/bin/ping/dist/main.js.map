{
  "version": 3,
  "sources": ["../../../../node_modules/@protobuf-ts/runtime/build/es2015/json-typings.js", "../../../../node_modules/@protobuf-ts/runtime/build/es2015/base64.js", "../../../../node_modules/@protobuf-ts/runtime/build/es2015/binary-format-contract.js", "../../../../node_modules/@protobuf-ts/runtime/build/es2015/goog-varint.js", "../../../../node_modules/@protobuf-ts/runtime/build/es2015/pb-long.js", "../../../../node_modules/@protobuf-ts/runtime/build/es2015/binary-reader.js", "../../../../node_modules/@protobuf-ts/runtime/build/es2015/assert.js", "../../../../node_modules/@protobuf-ts/runtime/build/es2015/binary-writer.js", "../../../../node_modules/@protobuf-ts/runtime/build/es2015/json-format-contract.js", "../../../../node_modules/@protobuf-ts/runtime/build/es2015/message-type-contract.js", "../../../../node_modules/@protobuf-ts/runtime/build/es2015/lower-camel-case.js", "../../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-info.js", "../../../../node_modules/@protobuf-ts/runtime/build/es2015/oneof.js", "../../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-type-check.js", "../../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-long-convert.js", "../../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-json-reader.js", "../../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-json-writer.js", "../../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-scalar-default.js", "../../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-binary-reader.js", "../../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-binary-writer.js", "../../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-create.js", "../../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-merge-partial.js", "../../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-equals.js", "../../../../node_modules/@protobuf-ts/runtime/build/es2015/message-type.js", "../../../contracts/errors/v1/errors.ts", "../../../contracts/pings/v1/pings.ts", "../../../lib/http/types.ts", "../../../lib/http/request.ts", "../../../lib/lib.ts", "../../../lib/middleware/context.ts", "../../../lib/protobuf-util.ts", "../../../lib/http/response.ts", "../../../lib/middleware/protobuf-middleware.ts", "../../../lib/middleware/router-middleware.ts", "../../../../node_modules/workers-loki-logger/src/lib.ts", "../../../../node_modules/workers-loki-logger/src/error-formatter.ts", "../../../../node_modules/workers-loki-logger/src/logger.ts", "../../../lib/logger.ts", "../../../lib/middleware/cors-middleware.ts", "../../../lib/middleware/logger-middleware.ts", "../../../lib/request-id-header.ts", "../../../lib/middleware/request-id-middleware.ts", "../../../lib/starter/on-fetch.ts", "../main.ts"],
  "sourcesContent": ["/**\n * Get the type of a JSON value.\n * Distinguishes between array, null and object.\n */\nexport function typeofJsonValue(value) {\n    let t = typeof value;\n    if (t == \"object\") {\n        if (Array.isArray(value))\n            return \"array\";\n        if (value === null)\n            return \"null\";\n    }\n    return t;\n}\n/**\n * Is this a JSON object (instead of an array or null)?\n */\nexport function isJsonObject(value) {\n    return value !== null && typeof value == \"object\" && !Array.isArray(value);\n}\n", "// lookup table from base64 character to byte\nlet encTable = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');\n// lookup table from base64 character *code* to byte because lookup by number is fast\nlet decTable = [];\nfor (let i = 0; i < encTable.length; i++)\n    decTable[encTable[i].charCodeAt(0)] = i;\n// support base64url variants\ndecTable[\"-\".charCodeAt(0)] = encTable.indexOf(\"+\");\ndecTable[\"_\".charCodeAt(0)] = encTable.indexOf(\"/\");\n/**\n * Decodes a base64 string to a byte array.\n *\n * - ignores white-space, including line breaks and tabs\n * - allows inner padding (can decode concatenated base64 strings)\n * - does not require padding\n * - understands base64url encoding:\n *   \"-\" instead of \"+\",\n *   \"_\" instead of \"/\",\n *   no padding\n */\nexport function base64decode(base64Str) {\n    // estimate byte size, not accounting for inner padding and whitespace\n    let es = base64Str.length * 3 / 4;\n    // if (es % 3 !== 0)\n    // throw new Error('invalid base64 string');\n    if (base64Str[base64Str.length - 2] == '=')\n        es -= 2;\n    else if (base64Str[base64Str.length - 1] == '=')\n        es -= 1;\n    let bytes = new Uint8Array(es), bytePos = 0, // position in byte array\n    groupPos = 0, // position in base64 group\n    b, // current byte\n    p = 0 // previous byte\n    ;\n    for (let i = 0; i < base64Str.length; i++) {\n        b = decTable[base64Str.charCodeAt(i)];\n        if (b === undefined) {\n            // noinspection FallThroughInSwitchStatementJS\n            switch (base64Str[i]) {\n                case '=':\n                    groupPos = 0; // reset state when padding found\n                case '\\n':\n                case '\\r':\n                case '\\t':\n                case ' ':\n                    continue; // skip white-space, and padding\n                default:\n                    throw Error(`invalid base64 string.`);\n            }\n        }\n        switch (groupPos) {\n            case 0:\n                p = b;\n                groupPos = 1;\n                break;\n            case 1:\n                bytes[bytePos++] = p << 2 | (b & 48) >> 4;\n                p = b;\n                groupPos = 2;\n                break;\n            case 2:\n                bytes[bytePos++] = (p & 15) << 4 | (b & 60) >> 2;\n                p = b;\n                groupPos = 3;\n                break;\n            case 3:\n                bytes[bytePos++] = (p & 3) << 6 | b;\n                groupPos = 0;\n                break;\n        }\n    }\n    if (groupPos == 1)\n        throw Error(`invalid base64 string.`);\n    return bytes.subarray(0, bytePos);\n}\n/**\n * Encodes a byte array to a base64 string.\n * Adds padding at the end.\n * Does not insert newlines.\n */\nexport function base64encode(bytes) {\n    let base64 = '', groupPos = 0, // position in base64 group\n    b, // current byte\n    p = 0; // carry over from previous byte\n    for (let i = 0; i < bytes.length; i++) {\n        b = bytes[i];\n        switch (groupPos) {\n            case 0:\n                base64 += encTable[b >> 2];\n                p = (b & 3) << 4;\n                groupPos = 1;\n                break;\n            case 1:\n                base64 += encTable[p | b >> 4];\n                p = (b & 15) << 2;\n                groupPos = 2;\n                break;\n            case 2:\n                base64 += encTable[p | b >> 6];\n                base64 += encTable[b & 63];\n                groupPos = 0;\n                break;\n        }\n    }\n    // padding required?\n    if (groupPos) {\n        base64 += encTable[p];\n        base64 += '=';\n        if (groupPos == 1)\n            base64 += '=';\n    }\n    return base64;\n}\n", "/**\n * This handler implements the default behaviour for unknown fields.\n * When reading data, unknown fields are stored on the message, in a\n * symbol property.\n * When writing data, the symbol property is queried and unknown fields\n * are serialized into the output again.\n */\nexport var UnknownFieldHandler;\n(function (UnknownFieldHandler) {\n    /**\n     * The symbol used to store unknown fields for a message.\n     * The property must conform to `UnknownFieldContainer`.\n     */\n    UnknownFieldHandler.symbol = Symbol.for(\"protobuf-ts/unknown\");\n    /**\n     * Store an unknown field during binary read directly on the message.\n     * This method is compatible with `BinaryReadOptions.readUnknownField`.\n     */\n    UnknownFieldHandler.onRead = (typeName, message, fieldNo, wireType, data) => {\n        let container = is(message) ? message[UnknownFieldHandler.symbol] : message[UnknownFieldHandler.symbol] = [];\n        container.push({ no: fieldNo, wireType, data });\n    };\n    /**\n     * Write unknown fields stored for the message to the writer.\n     * This method is compatible with `BinaryWriteOptions.writeUnknownFields`.\n     */\n    UnknownFieldHandler.onWrite = (typeName, message, writer) => {\n        for (let { no, wireType, data } of UnknownFieldHandler.list(message))\n            writer.tag(no, wireType).raw(data);\n    };\n    /**\n     * List unknown fields stored for the message.\n     * Note that there may be multiples fields with the same number.\n     */\n    UnknownFieldHandler.list = (message, fieldNo) => {\n        if (is(message)) {\n            let all = message[UnknownFieldHandler.symbol];\n            return fieldNo ? all.filter(uf => uf.no == fieldNo) : all;\n        }\n        return [];\n    };\n    /**\n     * Returns the last unknown field by field number.\n     */\n    UnknownFieldHandler.last = (message, fieldNo) => UnknownFieldHandler.list(message, fieldNo).slice(-1)[0];\n    const is = (message) => message && Array.isArray(message[UnknownFieldHandler.symbol]);\n})(UnknownFieldHandler || (UnknownFieldHandler = {}));\n/**\n * Merges binary write or read options. Later values override earlier values.\n */\nexport function mergeBinaryOptions(a, b) {\n    return Object.assign(Object.assign({}, a), b);\n}\n/**\n * Protobuf binary format wire types.\n *\n * A wire type provides just enough information to find the length of the\n * following value.\n *\n * See https://developers.google.com/protocol-buffers/docs/encoding#structure\n */\nexport var WireType;\n(function (WireType) {\n    /**\n     * Used for int32, int64, uint32, uint64, sint32, sint64, bool, enum\n     */\n    WireType[WireType[\"Varint\"] = 0] = \"Varint\";\n    /**\n     * Used for fixed64, sfixed64, double.\n     * Always 8 bytes with little-endian byte order.\n     */\n    WireType[WireType[\"Bit64\"] = 1] = \"Bit64\";\n    /**\n     * Used for string, bytes, embedded messages, packed repeated fields\n     *\n     * Only repeated numeric types (types which use the varint, 32-bit,\n     * or 64-bit wire types) can be packed. In proto3, such fields are\n     * packed by default.\n     */\n    WireType[WireType[\"LengthDelimited\"] = 2] = \"LengthDelimited\";\n    /**\n     * Used for groups\n     * @deprecated\n     */\n    WireType[WireType[\"StartGroup\"] = 3] = \"StartGroup\";\n    /**\n     * Used for groups\n     * @deprecated\n     */\n    WireType[WireType[\"EndGroup\"] = 4] = \"EndGroup\";\n    /**\n     * Used for fixed32, sfixed32, float.\n     * Always 4 bytes with little-endian byte order.\n     */\n    WireType[WireType[\"Bit32\"] = 5] = \"Bit32\";\n})(WireType || (WireType = {}));\n", "// Copyright 2008 Google Inc.  All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n// * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n// * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n// * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Code generated by the Protocol Buffer compiler is owned by the owner\n// of the input file used when generating it.  This code is not\n// standalone and requires a support library to be linked with it.  This\n// support library is itself covered by the above license.\n/**\n * Read a 64 bit varint as two JS numbers.\n *\n * Returns tuple:\n * [0]: low bits\n * [0]: high bits\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/buffer_decoder.js#L175\n */\nexport function varint64read() {\n    let lowBits = 0;\n    let highBits = 0;\n    for (let shift = 0; shift < 28; shift += 7) {\n        let b = this.buf[this.pos++];\n        lowBits |= (b & 0x7F) << shift;\n        if ((b & 0x80) == 0) {\n            this.assertBounds();\n            return [lowBits, highBits];\n        }\n    }\n    let middleByte = this.buf[this.pos++];\n    // last four bits of the first 32 bit number\n    lowBits |= (middleByte & 0x0F) << 28;\n    // 3 upper bits are part of the next 32 bit number\n    highBits = (middleByte & 0x70) >> 4;\n    if ((middleByte & 0x80) == 0) {\n        this.assertBounds();\n        return [lowBits, highBits];\n    }\n    for (let shift = 3; shift <= 31; shift += 7) {\n        let b = this.buf[this.pos++];\n        highBits |= (b & 0x7F) << shift;\n        if ((b & 0x80) == 0) {\n            this.assertBounds();\n            return [lowBits, highBits];\n        }\n    }\n    throw new Error('invalid varint');\n}\n/**\n * Write a 64 bit varint, given as two JS numbers, to the given bytes array.\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/writer.js#L344\n */\nexport function varint64write(lo, hi, bytes) {\n    for (let i = 0; i < 28; i = i + 7) {\n        const shift = lo >>> i;\n        const hasNext = !((shift >>> 7) == 0 && hi == 0);\n        const byte = (hasNext ? shift | 0x80 : shift) & 0xFF;\n        bytes.push(byte);\n        if (!hasNext) {\n            return;\n        }\n    }\n    const splitBits = ((lo >>> 28) & 0x0F) | ((hi & 0x07) << 4);\n    const hasMoreBits = !((hi >> 3) == 0);\n    bytes.push((hasMoreBits ? splitBits | 0x80 : splitBits) & 0xFF);\n    if (!hasMoreBits) {\n        return;\n    }\n    for (let i = 3; i < 31; i = i + 7) {\n        const shift = hi >>> i;\n        const hasNext = !((shift >>> 7) == 0);\n        const byte = (hasNext ? shift | 0x80 : shift) & 0xFF;\n        bytes.push(byte);\n        if (!hasNext) {\n            return;\n        }\n    }\n    bytes.push((hi >>> 31) & 0x01);\n}\n// constants for binary math\nconst TWO_PWR_32_DBL = (1 << 16) * (1 << 16);\n/**\n * Parse decimal string of 64 bit integer value as two JS numbers.\n *\n * Returns tuple:\n * [0]: minus sign?\n * [1]: low bits\n * [2]: high bits\n *\n * Copyright 2008 Google Inc.\n */\nexport function int64fromString(dec) {\n    // Check for minus sign.\n    let minus = dec[0] == '-';\n    if (minus)\n        dec = dec.slice(1);\n    // Work 6 decimal digits at a time, acting like we're converting base 1e6\n    // digits to binary. This is safe to do with floating point math because\n    // Number.isSafeInteger(ALL_32_BITS * 1e6) == true.\n    const base = 1e6;\n    let lowBits = 0;\n    let highBits = 0;\n    function add1e6digit(begin, end) {\n        // Note: Number('') is 0.\n        const digit1e6 = Number(dec.slice(begin, end));\n        highBits *= base;\n        lowBits = lowBits * base + digit1e6;\n        // Carry bits from lowBits to\n        if (lowBits >= TWO_PWR_32_DBL) {\n            highBits = highBits + ((lowBits / TWO_PWR_32_DBL) | 0);\n            lowBits = lowBits % TWO_PWR_32_DBL;\n        }\n    }\n    add1e6digit(-24, -18);\n    add1e6digit(-18, -12);\n    add1e6digit(-12, -6);\n    add1e6digit(-6);\n    return [minus, lowBits, highBits];\n}\n/**\n * Format 64 bit integer value (as two JS numbers) to decimal string.\n *\n * Copyright 2008 Google Inc.\n */\nexport function int64toString(bitsLow, bitsHigh) {\n    // Skip the expensive conversion if the number is small enough to use the\n    // built-in conversions.\n    if (bitsHigh <= 0x1FFFFF) {\n        return '' + (TWO_PWR_32_DBL * bitsHigh + bitsLow);\n    }\n    // What this code is doing is essentially converting the input number from\n    // base-2 to base-1e7, which allows us to represent the 64-bit range with\n    // only 3 (very large) digits. Those digits are then trivial to convert to\n    // a base-10 string.\n    // The magic numbers used here are -\n    // 2^24 = 16777216 = (1,6777216) in base-1e7.\n    // 2^48 = 281474976710656 = (2,8147497,6710656) in base-1e7.\n    // Split 32:32 representation into 16:24:24 representation so our\n    // intermediate digits don't overflow.\n    let low = bitsLow & 0xFFFFFF;\n    let mid = (((bitsLow >>> 24) | (bitsHigh << 8)) >>> 0) & 0xFFFFFF;\n    let high = (bitsHigh >> 16) & 0xFFFF;\n    // Assemble our three base-1e7 digits, ignoring carries. The maximum\n    // value in a digit at this step is representable as a 48-bit integer, which\n    // can be stored in a 64-bit floating point number.\n    let digitA = low + (mid * 6777216) + (high * 6710656);\n    let digitB = mid + (high * 8147497);\n    let digitC = (high * 2);\n    // Apply carries from A to B and from B to C.\n    let base = 10000000;\n    if (digitA >= base) {\n        digitB += Math.floor(digitA / base);\n        digitA %= base;\n    }\n    if (digitB >= base) {\n        digitC += Math.floor(digitB / base);\n        digitB %= base;\n    }\n    // Convert base-1e7 digits to base-10, with optional leading zeroes.\n    function decimalFrom1e7(digit1e7, needLeadingZeros) {\n        let partial = digit1e7 ? String(digit1e7) : '';\n        if (needLeadingZeros) {\n            return '0000000'.slice(partial.length) + partial;\n        }\n        return partial;\n    }\n    return decimalFrom1e7(digitC, /*needLeadingZeros=*/ 0) +\n        decimalFrom1e7(digitB, /*needLeadingZeros=*/ digitC) +\n        // If the final 1e7 digit didn't need leading zeros, we would have\n        // returned via the trivial code path at the top.\n        decimalFrom1e7(digitA, /*needLeadingZeros=*/ 1);\n}\n/**\n * Write a 32 bit varint, signed or unsigned. Same as `varint64write(0, value, bytes)`\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf/blob/1b18833f4f2a2f681f4e4a25cdf3b0a43115ec26/js/binary/encoder.js#L144\n */\nexport function varint32write(value, bytes) {\n    if (value >= 0) {\n        // write value as varint 32\n        while (value > 0x7f) {\n            bytes.push((value & 0x7f) | 0x80);\n            value = value >>> 7;\n        }\n        bytes.push(value);\n    }\n    else {\n        for (let i = 0; i < 9; i++) {\n            bytes.push(value & 127 | 128);\n            value = value >> 7;\n        }\n        bytes.push(1);\n    }\n}\n/**\n * Read an unsigned 32 bit varint.\n *\n * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/buffer_decoder.js#L220\n */\nexport function varint32read() {\n    let b = this.buf[this.pos++];\n    let result = b & 0x7F;\n    if ((b & 0x80) == 0) {\n        this.assertBounds();\n        return result;\n    }\n    b = this.buf[this.pos++];\n    result |= (b & 0x7F) << 7;\n    if ((b & 0x80) == 0) {\n        this.assertBounds();\n        return result;\n    }\n    b = this.buf[this.pos++];\n    result |= (b & 0x7F) << 14;\n    if ((b & 0x80) == 0) {\n        this.assertBounds();\n        return result;\n    }\n    b = this.buf[this.pos++];\n    result |= (b & 0x7F) << 21;\n    if ((b & 0x80) == 0) {\n        this.assertBounds();\n        return result;\n    }\n    // Extract only last 4 bits\n    b = this.buf[this.pos++];\n    result |= (b & 0x0F) << 28;\n    for (let readBytes = 5; ((b & 0x80) !== 0) && readBytes < 10; readBytes++)\n        b = this.buf[this.pos++];\n    if ((b & 0x80) != 0)\n        throw new Error('invalid varint');\n    this.assertBounds();\n    // Result can have 32 bits, convert it to unsigned\n    return result >>> 0;\n}\n", "import { int64fromString, int64toString } from \"./goog-varint\";\nfunction detectBi() {\n    const dv = new DataView(new ArrayBuffer(8));\n    const ok = globalThis.BigInt !== undefined\n        && typeof dv.getBigInt64 === \"function\"\n        && typeof dv.getBigUint64 === \"function\"\n        && typeof dv.setBigInt64 === \"function\"\n        && typeof dv.setBigUint64 === \"function\";\n    return ok ? {\n        MIN: BigInt(\"-9223372036854775808\"),\n        MAX: BigInt(\"9223372036854775807\"),\n        UMIN: BigInt(\"0\"),\n        UMAX: BigInt(\"18446744073709551615\"),\n        C: BigInt,\n        V: dv,\n    } : undefined;\n}\nconst BI = detectBi();\nfunction assertBi(bi) {\n    if (!bi)\n        throw new Error(\"BigInt unavailable, see https://github.com/timostamm/protobuf-ts/blob/v1.0.8/MANUAL.md#bigint-support\");\n}\n// used to validate from(string) input (when bigint is unavailable)\nconst RE_DECIMAL_STR = /^-?[0-9]+$/;\n// constants for binary math\nconst TWO_PWR_32_DBL = (1 << 16) * (1 << 16);\n// base class for PbLong and PbULong provides shared code\nclass SharedPbLong {\n    /**\n     * Create a new instance with the given bits.\n     */\n    constructor(lo, hi) {\n        this.lo = lo | 0;\n        this.hi = hi | 0;\n    }\n    /**\n     * Is this instance equal to 0?\n     */\n    isZero() {\n        return this.lo == 0 && this.hi == 0;\n    }\n    /**\n     * Convert to a native number.\n     */\n    toNumber() {\n        let result = this.hi * TWO_PWR_32_DBL + (this.lo >>> 0);\n        if (!Number.isSafeInteger(result))\n            throw new Error(\"cannot convert to safe number\");\n        return result;\n    }\n}\n/**\n * 64-bit unsigned integer as two 32-bit values.\n * Converts between `string`, `number` and `bigint` representations.\n */\nexport class PbULong extends SharedPbLong {\n    /**\n     * Create instance from a `string`, `number` or `bigint`.\n     */\n    static from(value) {\n        if (BI)\n            // noinspection FallThroughInSwitchStatementJS\n            switch (typeof value) {\n                case \"string\":\n                    if (value == \"0\")\n                        return this.ZERO;\n                    if (value == \"\")\n                        throw new Error('string is no integer');\n                    value = BI.C(value);\n                case \"number\":\n                    if (value === 0)\n                        return this.ZERO;\n                    value = BI.C(value);\n                case \"bigint\":\n                    if (!value)\n                        return this.ZERO;\n                    if (value < BI.UMIN)\n                        throw new Error('signed value for ulong');\n                    if (value > BI.UMAX)\n                        throw new Error('ulong too large');\n                    BI.V.setBigUint64(0, value, true);\n                    return new PbULong(BI.V.getInt32(0, true), BI.V.getInt32(4, true));\n            }\n        else\n            switch (typeof value) {\n                case \"string\":\n                    if (value == \"0\")\n                        return this.ZERO;\n                    value = value.trim();\n                    if (!RE_DECIMAL_STR.test(value))\n                        throw new Error('string is no integer');\n                    let [minus, lo, hi] = int64fromString(value);\n                    if (minus)\n                        throw new Error('signed value');\n                    return new PbULong(lo, hi);\n                case \"number\":\n                    if (value == 0)\n                        return this.ZERO;\n                    if (!Number.isSafeInteger(value))\n                        throw new Error('number is no integer');\n                    if (value < 0)\n                        throw new Error('signed value for ulong');\n                    return new PbULong(value, value / TWO_PWR_32_DBL);\n            }\n        throw new Error('unknown value ' + typeof value);\n    }\n    /**\n     * Convert to decimal string.\n     */\n    toString() {\n        return BI ? this.toBigInt().toString() : int64toString(this.lo, this.hi);\n    }\n    /**\n     * Convert to native bigint.\n     */\n    toBigInt() {\n        assertBi(BI);\n        BI.V.setInt32(0, this.lo, true);\n        BI.V.setInt32(4, this.hi, true);\n        return BI.V.getBigUint64(0, true);\n    }\n}\n/**\n * ulong 0 singleton.\n */\nPbULong.ZERO = new PbULong(0, 0);\n/**\n * 64-bit signed integer as two 32-bit values.\n * Converts between `string`, `number` and `bigint` representations.\n */\nexport class PbLong extends SharedPbLong {\n    /**\n     * Create instance from a `string`, `number` or `bigint`.\n     */\n    static from(value) {\n        if (BI)\n            // noinspection FallThroughInSwitchStatementJS\n            switch (typeof value) {\n                case \"string\":\n                    if (value == \"0\")\n                        return this.ZERO;\n                    if (value == \"\")\n                        throw new Error('string is no integer');\n                    value = BI.C(value);\n                case \"number\":\n                    if (value === 0)\n                        return this.ZERO;\n                    value = BI.C(value);\n                case \"bigint\":\n                    if (!value)\n                        return this.ZERO;\n                    if (value < BI.MIN)\n                        throw new Error('ulong too small');\n                    if (value > BI.MAX)\n                        throw new Error('ulong too large');\n                    BI.V.setBigInt64(0, value, true);\n                    return new PbLong(BI.V.getInt32(0, true), BI.V.getInt32(4, true));\n            }\n        else\n            switch (typeof value) {\n                case \"string\":\n                    if (value == \"0\")\n                        return this.ZERO;\n                    value = value.trim();\n                    if (!RE_DECIMAL_STR.test(value))\n                        throw new Error('string is no integer');\n                    let [minus, lo, hi] = int64fromString(value);\n                    let pbl = new PbLong(lo, hi);\n                    return minus ? pbl.negate() : pbl;\n                case \"number\":\n                    if (value == 0)\n                        return this.ZERO;\n                    if (!Number.isSafeInteger(value))\n                        throw new Error('number is no integer');\n                    return value > 0\n                        ? new PbLong(value, value / TWO_PWR_32_DBL)\n                        : new PbLong(-value, -value / TWO_PWR_32_DBL).negate();\n            }\n        throw new Error('unknown value ' + typeof value);\n    }\n    /**\n     * Do we have a minus sign?\n     */\n    isNegative() {\n        return (this.hi & 0x80000000) !== 0;\n    }\n    /**\n     * Negate two's complement.\n     * Invert all the bits and add one to the result.\n     */\n    negate() {\n        let hi = ~this.hi, lo = this.lo;\n        if (lo)\n            lo = ~lo + 1;\n        else\n            hi += 1;\n        return new PbLong(lo, hi);\n    }\n    /**\n     * Convert to decimal string.\n     */\n    toString() {\n        if (BI)\n            return this.toBigInt().toString();\n        if (this.isNegative()) {\n            let n = this.negate();\n            return '-' + int64toString(n.lo, n.hi);\n        }\n        return int64toString(this.lo, this.hi);\n    }\n    /**\n     * Convert to native bigint.\n     */\n    toBigInt() {\n        assertBi(BI);\n        BI.V.setInt32(0, this.lo, true);\n        BI.V.setInt32(4, this.hi, true);\n        return BI.V.getBigInt64(0, true);\n    }\n}\n/**\n * long 0 singleton.\n */\nPbLong.ZERO = new PbLong(0, 0);\n", "import { WireType } from \"./binary-format-contract\";\nimport { PbLong, PbULong } from \"./pb-long\";\nimport { varint32read, varint64read } from \"./goog-varint\";\nconst defaultsRead = {\n    readUnknownField: true,\n    readerFactory: bytes => new BinaryReader(bytes),\n};\n/**\n * Make options for reading binary data form partial options.\n */\nexport function binaryReadOptions(options) {\n    return options ? Object.assign(Object.assign({}, defaultsRead), options) : defaultsRead;\n}\nexport class BinaryReader {\n    constructor(buf, textDecoder) {\n        this.varint64 = varint64read; // dirty cast for `this`\n        /**\n         * Read a `uint32` field, an unsigned 32 bit varint.\n         */\n        this.uint32 = varint32read; // dirty cast for `this` and access to protected `buf`\n        this.buf = buf;\n        this.len = buf.length;\n        this.pos = 0;\n        this.view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        this.textDecoder = textDecoder !== null && textDecoder !== void 0 ? textDecoder : new TextDecoder(\"utf-8\", {\n            fatal: true\n        });\n    }\n    /**\n     * Reads a tag - field number and wire type.\n     */\n    tag() {\n        let tag = this.uint32(), fieldNo = tag >>> 3, wireType = tag & 7;\n        if (fieldNo <= 0 || wireType < 0 || wireType > 5)\n            throw new Error(\"illegal tag: field no \" + fieldNo + \" wire type \" + wireType);\n        return [fieldNo, wireType];\n    }\n    /**\n     * Skip one element on the wire and return the skipped data.\n     * Supports WireType.StartGroup since v2.0.0-alpha.23.\n     */\n    skip(wireType) {\n        let start = this.pos;\n        // noinspection FallThroughInSwitchStatementJS\n        switch (wireType) {\n            case WireType.Varint:\n                while (this.buf[this.pos++] & 0x80) {\n                    // ignore\n                }\n                break;\n            case WireType.Bit64:\n                this.pos += 4;\n            case WireType.Bit32:\n                this.pos += 4;\n                break;\n            case WireType.LengthDelimited:\n                let len = this.uint32();\n                this.pos += len;\n                break;\n            case WireType.StartGroup:\n                // From descriptor.proto: Group type is deprecated, not supported in proto3.\n                // But we must still be able to parse and treat as unknown.\n                let t;\n                while ((t = this.tag()[1]) !== WireType.EndGroup) {\n                    this.skip(t);\n                }\n                break;\n            default:\n                throw new Error(\"cant skip wire type \" + wireType);\n        }\n        this.assertBounds();\n        return this.buf.subarray(start, this.pos);\n    }\n    /**\n     * Throws error if position in byte array is out of range.\n     */\n    assertBounds() {\n        if (this.pos > this.len)\n            throw new RangeError(\"premature EOF\");\n    }\n    /**\n     * Read a `int32` field, a signed 32 bit varint.\n     */\n    int32() {\n        return this.uint32() | 0;\n    }\n    /**\n     * Read a `sint32` field, a signed, zigzag-encoded 32-bit varint.\n     */\n    sint32() {\n        let zze = this.uint32();\n        // decode zigzag\n        return (zze >>> 1) ^ -(zze & 1);\n    }\n    /**\n     * Read a `int64` field, a signed 64-bit varint.\n     */\n    int64() {\n        return new PbLong(...this.varint64());\n    }\n    /**\n     * Read a `uint64` field, an unsigned 64-bit varint.\n     */\n    uint64() {\n        return new PbULong(...this.varint64());\n    }\n    /**\n     * Read a `sint64` field, a signed, zig-zag-encoded 64-bit varint.\n     */\n    sint64() {\n        let [lo, hi] = this.varint64();\n        // decode zig zag\n        let s = -(lo & 1);\n        lo = ((lo >>> 1 | (hi & 1) << 31) ^ s);\n        hi = (hi >>> 1 ^ s);\n        return new PbLong(lo, hi);\n    }\n    /**\n     * Read a `bool` field, a variant.\n     */\n    bool() {\n        let [lo, hi] = this.varint64();\n        return lo !== 0 || hi !== 0;\n    }\n    /**\n     * Read a `fixed32` field, an unsigned, fixed-length 32-bit integer.\n     */\n    fixed32() {\n        return this.view.getUint32((this.pos += 4) - 4, true);\n    }\n    /**\n     * Read a `sfixed32` field, a signed, fixed-length 32-bit integer.\n     */\n    sfixed32() {\n        return this.view.getInt32((this.pos += 4) - 4, true);\n    }\n    /**\n     * Read a `fixed64` field, an unsigned, fixed-length 64 bit integer.\n     */\n    fixed64() {\n        return new PbULong(this.sfixed32(), this.sfixed32());\n    }\n    /**\n     * Read a `fixed64` field, a signed, fixed-length 64-bit integer.\n     */\n    sfixed64() {\n        return new PbLong(this.sfixed32(), this.sfixed32());\n    }\n    /**\n     * Read a `float` field, 32-bit floating point number.\n     */\n    float() {\n        return this.view.getFloat32((this.pos += 4) - 4, true);\n    }\n    /**\n     * Read a `double` field, a 64-bit floating point number.\n     */\n    double() {\n        return this.view.getFloat64((this.pos += 8) - 8, true);\n    }\n    /**\n     * Read a `bytes` field, length-delimited arbitrary data.\n     */\n    bytes() {\n        let len = this.uint32();\n        let start = this.pos;\n        this.pos += len;\n        this.assertBounds();\n        return this.buf.subarray(start, start + len);\n    }\n    /**\n     * Read a `string` field, length-delimited data converted to UTF-8 text.\n     */\n    string() {\n        return this.textDecoder.decode(this.bytes());\n    }\n}\n", "/**\n * assert that condition is true or throw error (with message)\n */\nexport function assert(condition, msg) {\n    if (!condition) {\n        throw new Error(msg);\n    }\n}\n/**\n * assert that value cannot exist = type `never`. throw runtime error if it does.\n */\nexport function assertNever(value, msg) {\n    throw new Error(msg !== null && msg !== void 0 ? msg : 'Unexpected object: ' + value);\n}\nconst FLOAT32_MAX = 3.4028234663852886e+38, FLOAT32_MIN = -3.4028234663852886e+38, UINT32_MAX = 0xFFFFFFFF, INT32_MAX = 0X7FFFFFFF, INT32_MIN = -0X80000000;\nexport function assertInt32(arg) {\n    if (typeof arg !== \"number\")\n        throw new Error('invalid int 32: ' + typeof arg);\n    if (!Number.isInteger(arg) || arg > INT32_MAX || arg < INT32_MIN)\n        throw new Error('invalid int 32: ' + arg);\n}\nexport function assertUInt32(arg) {\n    if (typeof arg !== \"number\")\n        throw new Error('invalid uint 32: ' + typeof arg);\n    if (!Number.isInteger(arg) || arg > UINT32_MAX || arg < 0)\n        throw new Error('invalid uint 32: ' + arg);\n}\nexport function assertFloat32(arg) {\n    if (typeof arg !== \"number\")\n        throw new Error('invalid float 32: ' + typeof arg);\n    if (!Number.isFinite(arg))\n        return;\n    if (arg > FLOAT32_MAX || arg < FLOAT32_MIN)\n        throw new Error('invalid float 32: ' + arg);\n}\n", "import { PbLong, PbULong } from \"./pb-long\";\nimport { varint32write, varint64write } from \"./goog-varint\";\nimport { assertFloat32, assertInt32, assertUInt32 } from \"./assert\";\nconst defaultsWrite = {\n    writeUnknownFields: true,\n    writerFactory: () => new BinaryWriter(),\n};\n/**\n * Make options for writing binary data form partial options.\n */\nexport function binaryWriteOptions(options) {\n    return options ? Object.assign(Object.assign({}, defaultsWrite), options) : defaultsWrite;\n}\nexport class BinaryWriter {\n    constructor(textEncoder) {\n        /**\n         * Previous fork states.\n         */\n        this.stack = [];\n        this.textEncoder = textEncoder !== null && textEncoder !== void 0 ? textEncoder : new TextEncoder();\n        this.chunks = [];\n        this.buf = [];\n    }\n    /**\n     * Return all bytes written and reset this writer.\n     */\n    finish() {\n        this.chunks.push(new Uint8Array(this.buf)); // flush the buffer\n        let len = 0;\n        for (let i = 0; i < this.chunks.length; i++)\n            len += this.chunks[i].length;\n        let bytes = new Uint8Array(len);\n        let offset = 0;\n        for (let i = 0; i < this.chunks.length; i++) {\n            bytes.set(this.chunks[i], offset);\n            offset += this.chunks[i].length;\n        }\n        this.chunks = [];\n        return bytes;\n    }\n    /**\n     * Start a new fork for length-delimited data like a message\n     * or a packed repeated field.\n     *\n     * Must be joined later with `join()`.\n     */\n    fork() {\n        this.stack.push({ chunks: this.chunks, buf: this.buf });\n        this.chunks = [];\n        this.buf = [];\n        return this;\n    }\n    /**\n     * Join the last fork. Write its length and bytes, then\n     * return to the previous state.\n     */\n    join() {\n        // get chunk of fork\n        let chunk = this.finish();\n        // restore previous state\n        let prev = this.stack.pop();\n        if (!prev)\n            throw new Error('invalid state, fork stack empty');\n        this.chunks = prev.chunks;\n        this.buf = prev.buf;\n        // write length of chunk as varint\n        this.uint32(chunk.byteLength);\n        return this.raw(chunk);\n    }\n    /**\n     * Writes a tag (field number and wire type).\n     *\n     * Equivalent to `uint32( (fieldNo << 3 | type) >>> 0 )`.\n     *\n     * Generated code should compute the tag ahead of time and call `uint32()`.\n     */\n    tag(fieldNo, type) {\n        return this.uint32((fieldNo << 3 | type) >>> 0);\n    }\n    /**\n     * Write a chunk of raw bytes.\n     */\n    raw(chunk) {\n        if (this.buf.length) {\n            this.chunks.push(new Uint8Array(this.buf));\n            this.buf = [];\n        }\n        this.chunks.push(chunk);\n        return this;\n    }\n    /**\n     * Write a `uint32` value, an unsigned 32 bit varint.\n     */\n    uint32(value) {\n        assertUInt32(value);\n        // write value as varint 32, inlined for speed\n        while (value > 0x7f) {\n            this.buf.push((value & 0x7f) | 0x80);\n            value = value >>> 7;\n        }\n        this.buf.push(value);\n        return this;\n    }\n    /**\n     * Write a `int32` value, a signed 32 bit varint.\n     */\n    int32(value) {\n        assertInt32(value);\n        varint32write(value, this.buf);\n        return this;\n    }\n    /**\n     * Write a `bool` value, a variant.\n     */\n    bool(value) {\n        this.buf.push(value ? 1 : 0);\n        return this;\n    }\n    /**\n     * Write a `bytes` value, length-delimited arbitrary data.\n     */\n    bytes(value) {\n        this.uint32(value.byteLength); // write length of chunk as varint\n        return this.raw(value);\n    }\n    /**\n     * Write a `string` value, length-delimited data converted to UTF-8 text.\n     */\n    string(value) {\n        let chunk = this.textEncoder.encode(value);\n        this.uint32(chunk.byteLength); // write length of chunk as varint\n        return this.raw(chunk);\n    }\n    /**\n     * Write a `float` value, 32-bit floating point number.\n     */\n    float(value) {\n        assertFloat32(value);\n        let chunk = new Uint8Array(4);\n        new DataView(chunk.buffer).setFloat32(0, value, true);\n        return this.raw(chunk);\n    }\n    /**\n     * Write a `double` value, a 64-bit floating point number.\n     */\n    double(value) {\n        let chunk = new Uint8Array(8);\n        new DataView(chunk.buffer).setFloat64(0, value, true);\n        return this.raw(chunk);\n    }\n    /**\n     * Write a `fixed32` value, an unsigned, fixed-length 32-bit integer.\n     */\n    fixed32(value) {\n        assertUInt32(value);\n        let chunk = new Uint8Array(4);\n        new DataView(chunk.buffer).setUint32(0, value, true);\n        return this.raw(chunk);\n    }\n    /**\n     * Write a `sfixed32` value, a signed, fixed-length 32-bit integer.\n     */\n    sfixed32(value) {\n        assertInt32(value);\n        let chunk = new Uint8Array(4);\n        new DataView(chunk.buffer).setInt32(0, value, true);\n        return this.raw(chunk);\n    }\n    /**\n     * Write a `sint32` value, a signed, zigzag-encoded 32-bit varint.\n     */\n    sint32(value) {\n        assertInt32(value);\n        // zigzag encode\n        value = ((value << 1) ^ (value >> 31)) >>> 0;\n        varint32write(value, this.buf);\n        return this;\n    }\n    /**\n     * Write a `fixed64` value, a signed, fixed-length 64-bit integer.\n     */\n    sfixed64(value) {\n        let chunk = new Uint8Array(8);\n        let view = new DataView(chunk.buffer);\n        let long = PbLong.from(value);\n        view.setInt32(0, long.lo, true);\n        view.setInt32(4, long.hi, true);\n        return this.raw(chunk);\n    }\n    /**\n     * Write a `fixed64` value, an unsigned, fixed-length 64 bit integer.\n     */\n    fixed64(value) {\n        let chunk = new Uint8Array(8);\n        let view = new DataView(chunk.buffer);\n        let long = PbULong.from(value);\n        view.setInt32(0, long.lo, true);\n        view.setInt32(4, long.hi, true);\n        return this.raw(chunk);\n    }\n    /**\n     * Write a `int64` value, a signed 64-bit varint.\n     */\n    int64(value) {\n        let long = PbLong.from(value);\n        varint64write(long.lo, long.hi, this.buf);\n        return this;\n    }\n    /**\n     * Write a `sint64` value, a signed, zig-zag-encoded 64-bit varint.\n     */\n    sint64(value) {\n        let long = PbLong.from(value), \n        // zigzag encode\n        sign = long.hi >> 31, lo = (long.lo << 1) ^ sign, hi = ((long.hi << 1) | (long.lo >>> 31)) ^ sign;\n        varint64write(lo, hi, this.buf);\n        return this;\n    }\n    /**\n     * Write a `uint64` value, an unsigned 64-bit varint.\n     */\n    uint64(value) {\n        let long = PbULong.from(value);\n        varint64write(long.lo, long.hi, this.buf);\n        return this;\n    }\n}\n", "const defaultsWrite = {\n    emitDefaultValues: false,\n    enumAsInteger: false,\n    useProtoFieldName: false,\n    prettySpaces: 0,\n}, defaultsRead = {\n    ignoreUnknownFields: false,\n};\n/**\n * Make options for reading JSON data from partial options.\n */\nexport function jsonReadOptions(options) {\n    return options ? Object.assign(Object.assign({}, defaultsRead), options) : defaultsRead;\n}\n/**\n * Make options for writing JSON data from partial options.\n */\nexport function jsonWriteOptions(options) {\n    return options ? Object.assign(Object.assign({}, defaultsWrite), options) : defaultsWrite;\n}\n/**\n * Merges JSON write or read options. Later values override earlier values. Type registries are merged.\n */\nexport function mergeJsonOptions(a, b) {\n    var _a, _b;\n    let c = Object.assign(Object.assign({}, a), b);\n    c.typeRegistry = [...((_a = a === null || a === void 0 ? void 0 : a.typeRegistry) !== null && _a !== void 0 ? _a : []), ...((_b = b === null || b === void 0 ? void 0 : b.typeRegistry) !== null && _b !== void 0 ? _b : [])];\n    return c;\n}\n", "/**\n * The symbol used as a key on message objects to store the message type.\n *\n * Note that this is an experimental feature - it is here to stay, but\n * implementation details may change without notice.\n */\nexport const MESSAGE_TYPE = Symbol.for(\"protobuf-ts/message-type\");\n", "/**\n * Converts snake_case to lowerCamelCase.\n *\n * Should behave like protoc:\n * https://github.com/protocolbuffers/protobuf/blob/e8ae137c96444ea313485ed1118c5e43b2099cf1/src/google/protobuf/compiler/java/java_helpers.cc#L118\n */\nexport function lowerCamelCase(snakeCase) {\n    let capNext = false;\n    const sb = [];\n    for (let i = 0; i < snakeCase.length; i++) {\n        let next = snakeCase.charAt(i);\n        if (next == '_') {\n            capNext = true;\n        }\n        else if (/\\d/.test(next)) {\n            sb.push(next);\n            capNext = true;\n        }\n        else if (capNext) {\n            sb.push(next.toUpperCase());\n            capNext = false;\n        }\n        else if (i == 0) {\n            sb.push(next.toLowerCase());\n        }\n        else {\n            sb.push(next);\n        }\n    }\n    return sb.join('');\n}\n", "import { lowerCamelCase } from \"./lower-camel-case\";\n/**\n * Scalar value types. This is a subset of field types declared by protobuf\n * enum google.protobuf.FieldDescriptorProto.Type The types GROUP and MESSAGE\n * are omitted, but the numerical values are identical.\n */\nexport var ScalarType;\n(function (ScalarType) {\n    // 0 is reserved for errors.\n    // Order is weird for historical reasons.\n    ScalarType[ScalarType[\"DOUBLE\"] = 1] = \"DOUBLE\";\n    ScalarType[ScalarType[\"FLOAT\"] = 2] = \"FLOAT\";\n    // Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT64 if\n    // negative values are likely.\n    ScalarType[ScalarType[\"INT64\"] = 3] = \"INT64\";\n    ScalarType[ScalarType[\"UINT64\"] = 4] = \"UINT64\";\n    // Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT32 if\n    // negative values are likely.\n    ScalarType[ScalarType[\"INT32\"] = 5] = \"INT32\";\n    ScalarType[ScalarType[\"FIXED64\"] = 6] = \"FIXED64\";\n    ScalarType[ScalarType[\"FIXED32\"] = 7] = \"FIXED32\";\n    ScalarType[ScalarType[\"BOOL\"] = 8] = \"BOOL\";\n    ScalarType[ScalarType[\"STRING\"] = 9] = \"STRING\";\n    // Tag-delimited aggregate.\n    // Group type is deprecated and not supported in proto3. However, Proto3\n    // implementations should still be able to parse the group wire format and\n    // treat group fields as unknown fields.\n    // TYPE_GROUP = 10,\n    // TYPE_MESSAGE = 11,  // Length-delimited aggregate.\n    // New in version 2.\n    ScalarType[ScalarType[\"BYTES\"] = 12] = \"BYTES\";\n    ScalarType[ScalarType[\"UINT32\"] = 13] = \"UINT32\";\n    // TYPE_ENUM = 14,\n    ScalarType[ScalarType[\"SFIXED32\"] = 15] = \"SFIXED32\";\n    ScalarType[ScalarType[\"SFIXED64\"] = 16] = \"SFIXED64\";\n    ScalarType[ScalarType[\"SINT32\"] = 17] = \"SINT32\";\n    ScalarType[ScalarType[\"SINT64\"] = 18] = \"SINT64\";\n})(ScalarType || (ScalarType = {}));\n/**\n * JavaScript representation of 64 bit integral types. Equivalent to the\n * field option \"jstype\".\n *\n * By default, protobuf-ts represents 64 bit types as `bigint`.\n *\n * You can change the default behaviour by enabling the plugin parameter\n * `long_type_string`, which will represent 64 bit types as `string`.\n *\n * Alternatively, you can change the behaviour for individual fields\n * with the field option \"jstype\":\n *\n * ```protobuf\n * uint64 my_field = 1 [jstype = JS_STRING];\n * uint64 other_field = 2 [jstype = JS_NUMBER];\n * ```\n */\nexport var LongType;\n(function (LongType) {\n    /**\n     * Use JavaScript `bigint`.\n     *\n     * Field option `[jstype = JS_NORMAL]`.\n     */\n    LongType[LongType[\"BIGINT\"] = 0] = \"BIGINT\";\n    /**\n     * Use JavaScript `string`.\n     *\n     * Field option `[jstype = JS_STRING]`.\n     */\n    LongType[LongType[\"STRING\"] = 1] = \"STRING\";\n    /**\n     * Use JavaScript `number`.\n     *\n     * Large values will loose precision.\n     *\n     * Field option `[jstype = JS_NUMBER]`.\n     */\n    LongType[LongType[\"NUMBER\"] = 2] = \"NUMBER\";\n})(LongType || (LongType = {}));\n/**\n * Protobuf 2.1.0 introduced packed repeated fields.\n * Setting the field option `[packed = true]` enables packing.\n *\n * In proto3, all repeated fields are packed by default.\n * Setting the field option `[packed = false]` disables packing.\n *\n * Packed repeated fields are encoded with a single tag,\n * then a length-delimiter, then the element values.\n *\n * Unpacked repeated fields are encoded with a tag and\n * value for each element.\n *\n * `bytes` and `string` cannot be packed.\n */\nexport var RepeatType;\n(function (RepeatType) {\n    /**\n     * The field is not repeated.\n     */\n    RepeatType[RepeatType[\"NO\"] = 0] = \"NO\";\n    /**\n     * The field is repeated and should be packed.\n     * Invalid for `bytes` and `string`, they cannot be packed.\n     */\n    RepeatType[RepeatType[\"PACKED\"] = 1] = \"PACKED\";\n    /**\n     * The field is repeated but should not be packed.\n     * The only valid repeat type for repeated `bytes` and `string`.\n     */\n    RepeatType[RepeatType[\"UNPACKED\"] = 2] = \"UNPACKED\";\n})(RepeatType || (RepeatType = {}));\n/**\n * Turns PartialFieldInfo into FieldInfo.\n */\nexport function normalizeFieldInfo(field) {\n    var _a, _b, _c, _d;\n    field.localName = (_a = field.localName) !== null && _a !== void 0 ? _a : lowerCamelCase(field.name);\n    field.jsonName = (_b = field.jsonName) !== null && _b !== void 0 ? _b : lowerCamelCase(field.name);\n    field.repeat = (_c = field.repeat) !== null && _c !== void 0 ? _c : RepeatType.NO;\n    field.opt = (_d = field.opt) !== null && _d !== void 0 ? _d : (field.repeat ? false : field.oneof ? false : field.kind == \"message\");\n    return field;\n}\n/**\n * Read custom field options from a generated message type.\n *\n * @deprecated use readFieldOption()\n */\nexport function readFieldOptions(messageType, fieldName, extensionName, extensionType) {\n    var _a;\n    const options = (_a = messageType.fields.find((m, i) => m.localName == fieldName || i == fieldName)) === null || _a === void 0 ? void 0 : _a.options;\n    return options && options[extensionName] ? extensionType.fromJson(options[extensionName]) : undefined;\n}\nexport function readFieldOption(messageType, fieldName, extensionName, extensionType) {\n    var _a;\n    const options = (_a = messageType.fields.find((m, i) => m.localName == fieldName || i == fieldName)) === null || _a === void 0 ? void 0 : _a.options;\n    if (!options) {\n        return undefined;\n    }\n    const optionVal = options[extensionName];\n    if (optionVal === undefined) {\n        return optionVal;\n    }\n    return extensionType ? extensionType.fromJson(optionVal) : optionVal;\n}\nexport function readMessageOption(messageType, extensionName, extensionType) {\n    const options = messageType.options;\n    const optionVal = options[extensionName];\n    if (optionVal === undefined) {\n        return optionVal;\n    }\n    return extensionType ? extensionType.fromJson(optionVal) : optionVal;\n}\n", "/**\n * Is the given value a valid oneof group?\n *\n * We represent protobuf `oneof` as algebraic data types (ADT) in generated\n * code. But when working with messages of unknown type, the ADT does not\n * help us.\n *\n * This type guard checks if the given object adheres to the ADT rules, which\n * are as follows:\n *\n * 1) Must be an object.\n *\n * 2) Must have a \"oneofKind\" discriminator property.\n *\n * 3) If \"oneofKind\" is `undefined`, no member field is selected. The object\n * must not have any other properties.\n *\n * 4) If \"oneofKind\" is a `string`, the member field with this name is\n * selected.\n *\n * 5) If a member field is selected, the object must have a second property\n * with this name. The property must not be `undefined`.\n *\n * 6) No extra properties are allowed. The object has either one property\n * (no selection) or two properties (selection).\n *\n */\nexport function isOneofGroup(any) {\n    if (typeof any != 'object' || any === null || !any.hasOwnProperty('oneofKind')) {\n        return false;\n    }\n    switch (typeof any.oneofKind) {\n        case \"string\":\n            if (any[any.oneofKind] === undefined)\n                return false;\n            return Object.keys(any).length == 2;\n        case \"undefined\":\n            return Object.keys(any).length == 1;\n        default:\n            return false;\n    }\n}\n/**\n * Returns the value of the given field in a oneof group.\n */\nexport function getOneofValue(oneof, kind) {\n    return oneof[kind];\n}\nexport function setOneofValue(oneof, kind, value) {\n    if (oneof.oneofKind !== undefined) {\n        delete oneof[oneof.oneofKind];\n    }\n    oneof.oneofKind = kind;\n    if (value !== undefined) {\n        oneof[kind] = value;\n    }\n}\nexport function setUnknownOneofValue(oneof, kind, value) {\n    if (oneof.oneofKind !== undefined) {\n        delete oneof[oneof.oneofKind];\n    }\n    oneof.oneofKind = kind;\n    if (value !== undefined && kind !== undefined) {\n        oneof[kind] = value;\n    }\n}\n/**\n * Removes the selected field in a oneof group.\n *\n * Note that the recommended way to modify a oneof group is to set\n * a new object:\n *\n * ```ts\n * message.result = { oneofKind: undefined };\n * ```\n */\nexport function clearOneofValue(oneof) {\n    if (oneof.oneofKind !== undefined) {\n        delete oneof[oneof.oneofKind];\n    }\n    oneof.oneofKind = undefined;\n}\n/**\n * Returns the selected value of the given oneof group.\n *\n * Not that the recommended way to access a oneof group is to check\n * the \"oneofKind\" property and let TypeScript narrow down the union\n * type for you:\n *\n * ```ts\n * if (message.result.oneofKind === \"error\") {\n *   message.result.error; // string\n * }\n * ```\n *\n * In the rare case you just need the value, and do not care about\n * which protobuf field is selected, you can use this function\n * for convenience.\n */\nexport function getSelectedOneofValue(oneof) {\n    if (oneof.oneofKind === undefined) {\n        return undefined;\n    }\n    return oneof[oneof.oneofKind];\n}\n", "import { LongType, ScalarType } from \"./reflection-info\";\nimport { isOneofGroup } from \"./oneof\";\n// noinspection JSMethodCanBeStatic\nexport class ReflectionTypeCheck {\n    constructor(info) {\n        var _a;\n        this.fields = (_a = info.fields) !== null && _a !== void 0 ? _a : [];\n    }\n    prepare() {\n        if (this.data)\n            return;\n        const req = [], known = [], oneofs = [];\n        for (let field of this.fields) {\n            if (field.oneof) {\n                if (!oneofs.includes(field.oneof)) {\n                    oneofs.push(field.oneof);\n                    req.push(field.oneof);\n                    known.push(field.oneof);\n                }\n            }\n            else {\n                known.push(field.localName);\n                switch (field.kind) {\n                    case \"scalar\":\n                    case \"enum\":\n                        if (!field.opt || field.repeat)\n                            req.push(field.localName);\n                        break;\n                    case \"message\":\n                        if (field.repeat)\n                            req.push(field.localName);\n                        break;\n                    case \"map\":\n                        req.push(field.localName);\n                        break;\n                }\n            }\n        }\n        this.data = { req, known, oneofs: Object.values(oneofs) };\n    }\n    /**\n     * Is the argument a valid message as specified by the\n     * reflection information?\n     *\n     * Checks all field types recursively. The `depth`\n     * specifies how deep into the structure the check will be.\n     *\n     * With a depth of 0, only the presence of fields\n     * is checked.\n     *\n     * With a depth of 1 or more, the field types are checked.\n     *\n     * With a depth of 2 or more, the members of map, repeated\n     * and message fields are checked.\n     *\n     * Message fields will be checked recursively with depth - 1.\n     *\n     * The number of map entries / repeated values being checked\n     * is < depth.\n     */\n    is(message, depth, allowExcessProperties = false) {\n        if (depth < 0)\n            return true;\n        if (message === null || message === undefined || typeof message != 'object')\n            return false;\n        this.prepare();\n        let keys = Object.keys(message), data = this.data;\n        // if a required field is missing in arg, this cannot be a T\n        if (keys.length < data.req.length || data.req.some(n => !keys.includes(n)))\n            return false;\n        if (!allowExcessProperties) {\n            // if the arg contains a key we dont know, this is not a literal T\n            if (keys.some(k => !data.known.includes(k)))\n                return false;\n        }\n        // \"With a depth of 0, only the presence and absence of fields is checked.\"\n        // \"With a depth of 1 or more, the field types are checked.\"\n        if (depth < 1) {\n            return true;\n        }\n        // check oneof group\n        for (const name of data.oneofs) {\n            const group = message[name];\n            if (!isOneofGroup(group))\n                return false;\n            if (group.oneofKind === undefined)\n                continue;\n            const field = this.fields.find(f => f.localName === group.oneofKind);\n            if (!field)\n                return false; // we found no field, but have a kind, something is wrong\n            if (!this.field(group[group.oneofKind], field, allowExcessProperties, depth))\n                return false;\n        }\n        // check types\n        for (const field of this.fields) {\n            if (field.oneof !== undefined)\n                continue;\n            if (!this.field(message[field.localName], field, allowExcessProperties, depth))\n                return false;\n        }\n        return true;\n    }\n    field(arg, field, allowExcessProperties, depth) {\n        let repeated = field.repeat;\n        switch (field.kind) {\n            case \"scalar\":\n                if (arg === undefined)\n                    return field.opt;\n                if (repeated)\n                    return this.scalars(arg, field.T, depth, field.L);\n                return this.scalar(arg, field.T, field.L);\n            case \"enum\":\n                if (arg === undefined)\n                    return field.opt;\n                if (repeated)\n                    return this.scalars(arg, ScalarType.INT32, depth);\n                return this.scalar(arg, ScalarType.INT32);\n            case \"message\":\n                if (arg === undefined)\n                    return true;\n                if (repeated)\n                    return this.messages(arg, field.T(), allowExcessProperties, depth);\n                return this.message(arg, field.T(), allowExcessProperties, depth);\n            case \"map\":\n                if (typeof arg != 'object' || arg === null)\n                    return false;\n                if (depth < 2)\n                    return true;\n                if (!this.mapKeys(arg, field.K, depth))\n                    return false;\n                switch (field.V.kind) {\n                    case \"scalar\":\n                        return this.scalars(Object.values(arg), field.V.T, depth, field.V.L);\n                    case \"enum\":\n                        return this.scalars(Object.values(arg), ScalarType.INT32, depth);\n                    case \"message\":\n                        return this.messages(Object.values(arg), field.V.T(), allowExcessProperties, depth);\n                }\n                break;\n        }\n        return true;\n    }\n    message(arg, type, allowExcessProperties, depth) {\n        if (allowExcessProperties) {\n            return type.isAssignable(arg, depth);\n        }\n        return type.is(arg, depth);\n    }\n    messages(arg, type, allowExcessProperties, depth) {\n        if (!Array.isArray(arg))\n            return false;\n        if (depth < 2)\n            return true;\n        if (allowExcessProperties) {\n            for (let i = 0; i < arg.length && i < depth; i++)\n                if (!type.isAssignable(arg[i], depth - 1))\n                    return false;\n        }\n        else {\n            for (let i = 0; i < arg.length && i < depth; i++)\n                if (!type.is(arg[i], depth - 1))\n                    return false;\n        }\n        return true;\n    }\n    scalar(arg, type, longType) {\n        let argType = typeof arg;\n        switch (type) {\n            case ScalarType.UINT64:\n            case ScalarType.FIXED64:\n            case ScalarType.INT64:\n            case ScalarType.SFIXED64:\n            case ScalarType.SINT64:\n                switch (longType) {\n                    case LongType.BIGINT:\n                        return argType == \"bigint\";\n                    case LongType.NUMBER:\n                        return argType == \"number\" && !isNaN(arg);\n                    default:\n                        return argType == \"string\";\n                }\n            case ScalarType.BOOL:\n                return argType == 'boolean';\n            case ScalarType.STRING:\n                return argType == 'string';\n            case ScalarType.BYTES:\n                return arg instanceof Uint8Array;\n            case ScalarType.DOUBLE:\n            case ScalarType.FLOAT:\n                return argType == 'number' && !isNaN(arg);\n            default:\n                // case ScalarType.UINT32:\n                // case ScalarType.FIXED32:\n                // case ScalarType.INT32:\n                // case ScalarType.SINT32:\n                // case ScalarType.SFIXED32:\n                return argType == 'number' && Number.isInteger(arg);\n        }\n    }\n    scalars(arg, type, depth, longType) {\n        if (!Array.isArray(arg))\n            return false;\n        if (depth < 2)\n            return true;\n        if (Array.isArray(arg))\n            for (let i = 0; i < arg.length && i < depth; i++)\n                if (!this.scalar(arg[i], type, longType))\n                    return false;\n        return true;\n    }\n    mapKeys(map, type, depth) {\n        let keys = Object.keys(map);\n        switch (type) {\n            case ScalarType.INT32:\n            case ScalarType.FIXED32:\n            case ScalarType.SFIXED32:\n            case ScalarType.SINT32:\n            case ScalarType.UINT32:\n                return this.scalars(keys.slice(0, depth).map(k => parseInt(k)), type, depth);\n            case ScalarType.BOOL:\n                return this.scalars(keys.slice(0, depth).map(k => k == 'true' ? true : k == 'false' ? false : k), type, depth);\n            default:\n                return this.scalars(keys, type, depth, LongType.STRING);\n        }\n    }\n}\n", "import { LongType } from \"./reflection-info\";\n/**\n * Utility method to convert a PbLong or PbUlong to a JavaScript\n * representation during runtime.\n *\n * Works with generated field information, `undefined` is equivalent\n * to `STRING`.\n */\nexport function reflectionLongConvert(long, type) {\n    switch (type) {\n        case LongType.BIGINT:\n            return long.toBigInt();\n        case LongType.NUMBER:\n            return long.toNumber();\n        default:\n            // case undefined:\n            // case LongType.STRING:\n            return long.toString();\n    }\n}\n", "import { isJsonObject, typeofJsonValue } from \"./json-typings\";\nimport { base64decode } from \"./base64\";\nimport { LongType, ScalarType } from \"./reflection-info\";\nimport { PbLong, PbULong } from \"./pb-long\";\nimport { assert, assertFloat32, assertInt32, assertUInt32 } from \"./assert\";\nimport { reflectionLongConvert } from \"./reflection-long-convert\";\n/**\n * Reads proto3 messages in canonical JSON format using reflection information.\n *\n * https://developers.google.com/protocol-buffers/docs/proto3#json\n */\nexport class ReflectionJsonReader {\n    constructor(info) {\n        this.info = info;\n    }\n    prepare() {\n        var _a;\n        if (this.fMap === undefined) {\n            this.fMap = {};\n            const fieldsInput = (_a = this.info.fields) !== null && _a !== void 0 ? _a : [];\n            for (const field of fieldsInput) {\n                this.fMap[field.name] = field;\n                this.fMap[field.jsonName] = field;\n                this.fMap[field.localName] = field;\n            }\n        }\n    }\n    // Cannot parse JSON <type of jsonValue> for <type name>#<fieldName>.\n    assert(condition, fieldName, jsonValue) {\n        if (!condition) {\n            let what = typeofJsonValue(jsonValue);\n            if (what == \"number\" || what == \"boolean\")\n                what = jsonValue.toString();\n            throw new Error(`Cannot parse JSON ${what} for ${this.info.typeName}#${fieldName}`);\n        }\n    }\n    /**\n     * Reads a message from canonical JSON format into the target message.\n     *\n     * Repeated fields are appended. Map entries are added, overwriting\n     * existing keys.\n     *\n     * If a message field is already present, it will be merged with the\n     * new data.\n     */\n    read(input, message, options) {\n        this.prepare();\n        const oneofsHandled = [];\n        for (const [jsonKey, jsonValue] of Object.entries(input)) {\n            const field = this.fMap[jsonKey];\n            if (!field) {\n                if (!options.ignoreUnknownFields)\n                    throw new Error(`Found unknown field while reading ${this.info.typeName} from JSON format. JSON key: ${jsonKey}`);\n                continue;\n            }\n            const localName = field.localName;\n            // handle oneof ADT\n            let target; // this will be the target for the field value, whether it is member of a oneof or not\n            if (field.oneof) {\n                // since json objects are unordered by specification, it is not possible to take the last of multiple oneofs\n                if (oneofsHandled.includes(field.oneof))\n                    throw new Error(`Multiple members of the oneof group \"${field.oneof}\" of ${this.info.typeName} are present in JSON.`);\n                oneofsHandled.push(field.oneof);\n                target = message[field.oneof] = {\n                    oneofKind: localName\n                };\n            }\n            else {\n                target = message;\n            }\n            // we have handled oneof above. we just have read the value into `target`.\n            if (field.kind == 'map') {\n                if (jsonValue === null) {\n                    continue;\n                }\n                // check input\n                this.assert(isJsonObject(jsonValue), field.name, jsonValue);\n                // our target to put map entries into\n                const fieldObj = target[localName];\n                // read entries\n                for (const [jsonObjKey, jsonObjValue] of Object.entries(jsonValue)) {\n                    this.assert(jsonObjValue !== null, field.name + \" map value\", null);\n                    // read value\n                    let val;\n                    switch (field.V.kind) {\n                        case \"message\":\n                            val = field.V.T().internalJsonRead(jsonObjValue, options);\n                            break;\n                        case \"enum\":\n                            val = this.enum(field.V.T(), jsonObjValue, field.name, options.ignoreUnknownFields);\n                            if (val === false)\n                                continue;\n                            break;\n                        case \"scalar\":\n                            val = this.scalar(jsonObjValue, field.V.T, field.V.L, field.name);\n                            break;\n                    }\n                    this.assert(val !== undefined, field.name + \" map value\", jsonObjValue);\n                    // read key\n                    let key = jsonObjKey;\n                    if (field.K == ScalarType.BOOL)\n                        key = key == \"true\" ? true : key == \"false\" ? false : key;\n                    key = this.scalar(key, field.K, LongType.STRING, field.name).toString();\n                    fieldObj[key] = val;\n                }\n            }\n            else if (field.repeat) {\n                if (jsonValue === null)\n                    continue;\n                // check input\n                this.assert(Array.isArray(jsonValue), field.name, jsonValue);\n                // our target to put array entries into\n                const fieldArr = target[localName];\n                // read array entries\n                for (const jsonItem of jsonValue) {\n                    this.assert(jsonItem !== null, field.name, null);\n                    let val;\n                    switch (field.kind) {\n                        case \"message\":\n                            val = field.T().internalJsonRead(jsonItem, options);\n                            break;\n                        case \"enum\":\n                            val = this.enum(field.T(), jsonItem, field.name, options.ignoreUnknownFields);\n                            if (val === false)\n                                continue;\n                            break;\n                        case \"scalar\":\n                            val = this.scalar(jsonItem, field.T, field.L, field.name);\n                            break;\n                    }\n                    this.assert(val !== undefined, field.name, jsonValue);\n                    fieldArr.push(val);\n                }\n            }\n            else {\n                switch (field.kind) {\n                    case \"message\":\n                        if (jsonValue === null && field.T().typeName != 'google.protobuf.Value') {\n                            this.assert(field.oneof === undefined, field.name + \" (oneof member)\", null);\n                            continue;\n                        }\n                        target[localName] = field.T().internalJsonRead(jsonValue, options, target[localName]);\n                        break;\n                    case \"enum\":\n                        let val = this.enum(field.T(), jsonValue, field.name, options.ignoreUnknownFields);\n                        if (val === false)\n                            continue;\n                        target[localName] = val;\n                        break;\n                    case \"scalar\":\n                        target[localName] = this.scalar(jsonValue, field.T, field.L, field.name);\n                        break;\n                }\n            }\n        }\n    }\n    /**\n     * Returns `false` for unrecognized string representations.\n     *\n     * google.protobuf.NullValue accepts only JSON `null`.\n     */\n    enum(type, json, fieldName, ignoreUnknownFields) {\n        if (type[0] == 'google.protobuf.NullValue')\n            assert(json === null, `Unable to parse field ${this.info.typeName}#${fieldName}, enum ${type[0]} only accepts null.`);\n        if (json === null)\n            // we require 0 to be default value for all enums\n            return 0;\n        switch (typeof json) {\n            case \"number\":\n                assert(Number.isInteger(json), `Unable to parse field ${this.info.typeName}#${fieldName}, enum can only be integral number, got ${json}.`);\n                return json;\n            case \"string\":\n                let localEnumName = json;\n                if (type[2] && json.substring(0, type[2].length) === type[2])\n                    // lookup without the shared prefix\n                    localEnumName = json.substring(type[2].length);\n                let enumNumber = type[1][localEnumName];\n                if (typeof enumNumber === 'undefined' && ignoreUnknownFields) {\n                    return false;\n                }\n                assert(typeof enumNumber == \"number\", `Unable to parse field ${this.info.typeName}#${fieldName}, enum ${type[0]} has no value for \"${json}\".`);\n                return enumNumber;\n        }\n        assert(false, `Unable to parse field ${this.info.typeName}#${fieldName}, cannot parse enum value from ${typeof json}\".`);\n    }\n    scalar(json, type, longType, fieldName) {\n        let e;\n        try {\n            switch (type) {\n                // float, double: JSON value will be a number or one of the special string values \"NaN\", \"Infinity\", and \"-Infinity\".\n                // Either numbers or strings are accepted. Exponent notation is also accepted.\n                case ScalarType.DOUBLE:\n                case ScalarType.FLOAT:\n                    if (json === null)\n                        return .0;\n                    if (json === \"NaN\")\n                        return Number.NaN;\n                    if (json === \"Infinity\")\n                        return Number.POSITIVE_INFINITY;\n                    if (json === \"-Infinity\")\n                        return Number.NEGATIVE_INFINITY;\n                    if (json === \"\") {\n                        e = \"empty string\";\n                        break;\n                    }\n                    if (typeof json == \"string\" && json.trim().length !== json.length) {\n                        e = \"extra whitespace\";\n                        break;\n                    }\n                    if (typeof json != \"string\" && typeof json != \"number\") {\n                        break;\n                    }\n                    let float = Number(json);\n                    if (Number.isNaN(float)) {\n                        e = \"not a number\";\n                        break;\n                    }\n                    if (!Number.isFinite(float)) {\n                        // infinity and -infinity are handled by string representation above, so this is an error\n                        e = \"too large or small\";\n                        break;\n                    }\n                    if (type == ScalarType.FLOAT)\n                        assertFloat32(float);\n                    return float;\n                // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.\n                case ScalarType.INT32:\n                case ScalarType.FIXED32:\n                case ScalarType.SFIXED32:\n                case ScalarType.SINT32:\n                case ScalarType.UINT32:\n                    if (json === null)\n                        return 0;\n                    let int32;\n                    if (typeof json == \"number\")\n                        int32 = json;\n                    else if (json === \"\")\n                        e = \"empty string\";\n                    else if (typeof json == \"string\") {\n                        if (json.trim().length !== json.length)\n                            e = \"extra whitespace\";\n                        else\n                            int32 = Number(json);\n                    }\n                    if (int32 === undefined)\n                        break;\n                    if (type == ScalarType.UINT32)\n                        assertUInt32(int32);\n                    else\n                        assertInt32(int32);\n                    return int32;\n                // int64, fixed64, uint64: JSON value will be a decimal string. Either numbers or strings are accepted.\n                case ScalarType.INT64:\n                case ScalarType.SFIXED64:\n                case ScalarType.SINT64:\n                    if (json === null)\n                        return reflectionLongConvert(PbLong.ZERO, longType);\n                    if (typeof json != \"number\" && typeof json != \"string\")\n                        break;\n                    return reflectionLongConvert(PbLong.from(json), longType);\n                case ScalarType.FIXED64:\n                case ScalarType.UINT64:\n                    if (json === null)\n                        return reflectionLongConvert(PbULong.ZERO, longType);\n                    if (typeof json != \"number\" && typeof json != \"string\")\n                        break;\n                    return reflectionLongConvert(PbULong.from(json), longType);\n                // bool:\n                case ScalarType.BOOL:\n                    if (json === null)\n                        return false;\n                    if (typeof json !== \"boolean\")\n                        break;\n                    return json;\n                // string:\n                case ScalarType.STRING:\n                    if (json === null)\n                        return \"\";\n                    if (typeof json !== \"string\") {\n                        e = \"extra whitespace\";\n                        break;\n                    }\n                    try {\n                        encodeURIComponent(json);\n                    }\n                    catch (e) {\n                        e = \"invalid UTF8\";\n                        break;\n                    }\n                    return json;\n                // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.\n                // Either standard or URL-safe base64 encoding with/without paddings are accepted.\n                case ScalarType.BYTES:\n                    if (json === null || json === \"\")\n                        return new Uint8Array(0);\n                    if (typeof json !== 'string')\n                        break;\n                    return base64decode(json);\n            }\n        }\n        catch (error) {\n            e = error.message;\n        }\n        this.assert(false, fieldName + (e ? \" - \" + e : \"\"), json);\n    }\n}\n", "import { base64encode } from \"./base64\";\nimport { PbLong, PbULong } from \"./pb-long\";\nimport { ScalarType } from \"./reflection-info\";\nimport { assert, assertFloat32, assertInt32, assertUInt32 } from \"./assert\";\n/**\n * Writes proto3 messages in canonical JSON format using reflection\n * information.\n *\n * https://developers.google.com/protocol-buffers/docs/proto3#json\n */\nexport class ReflectionJsonWriter {\n    constructor(info) {\n        var _a;\n        this.fields = (_a = info.fields) !== null && _a !== void 0 ? _a : [];\n    }\n    /**\n     * Converts the message to a JSON object, based on the field descriptors.\n     */\n    write(message, options) {\n        const json = {}, source = message;\n        for (const field of this.fields) {\n            // field is not part of a oneof, simply write as is\n            if (!field.oneof) {\n                let jsonValue = this.field(field, source[field.localName], options);\n                if (jsonValue !== undefined)\n                    json[options.useProtoFieldName ? field.name : field.jsonName] = jsonValue;\n                continue;\n            }\n            // field is part of a oneof\n            const group = source[field.oneof];\n            if (group.oneofKind !== field.localName)\n                continue; // not selected, skip\n            const opt = field.kind == 'scalar' || field.kind == 'enum'\n                ? Object.assign(Object.assign({}, options), { emitDefaultValues: true }) : options;\n            let jsonValue = this.field(field, group[field.localName], opt);\n            assert(jsonValue !== undefined);\n            json[options.useProtoFieldName ? field.name : field.jsonName] = jsonValue;\n        }\n        return json;\n    }\n    field(field, value, options) {\n        let jsonValue = undefined;\n        if (field.kind == 'map') {\n            assert(typeof value == \"object\" && value !== null);\n            const jsonObj = {};\n            switch (field.V.kind) {\n                case \"scalar\":\n                    for (const [entryKey, entryValue] of Object.entries(value)) {\n                        const val = this.scalar(field.V.T, entryValue, field.name, false, true);\n                        assert(val !== undefined);\n                        jsonObj[entryKey.toString()] = val; // JSON standard allows only (double quoted) string as property key\n                    }\n                    break;\n                case \"message\":\n                    const messageType = field.V.T();\n                    for (const [entryKey, entryValue] of Object.entries(value)) {\n                        const val = this.message(messageType, entryValue, field.name, options);\n                        assert(val !== undefined);\n                        jsonObj[entryKey.toString()] = val; // JSON standard allows only (double quoted) string as property key\n                    }\n                    break;\n                case \"enum\":\n                    const enumInfo = field.V.T();\n                    for (const [entryKey, entryValue] of Object.entries(value)) {\n                        assert(entryValue === undefined || typeof entryValue == 'number');\n                        const val = this.enum(enumInfo, entryValue, field.name, false, true, options.enumAsInteger);\n                        assert(val !== undefined);\n                        jsonObj[entryKey.toString()] = val; // JSON standard allows only (double quoted) string as property key\n                    }\n                    break;\n            }\n            if (options.emitDefaultValues || Object.keys(jsonObj).length > 0)\n                jsonValue = jsonObj;\n        }\n        else if (field.repeat) {\n            assert(Array.isArray(value));\n            const jsonArr = [];\n            switch (field.kind) {\n                case \"scalar\":\n                    for (let i = 0; i < value.length; i++) {\n                        const val = this.scalar(field.T, value[i], field.name, field.opt, true);\n                        assert(val !== undefined);\n                        jsonArr.push(val);\n                    }\n                    break;\n                case \"enum\":\n                    const enumInfo = field.T();\n                    for (let i = 0; i < value.length; i++) {\n                        assert(value[i] === undefined || typeof value[i] == 'number');\n                        const val = this.enum(enumInfo, value[i], field.name, field.opt, true, options.enumAsInteger);\n                        assert(val !== undefined);\n                        jsonArr.push(val);\n                    }\n                    break;\n                case \"message\":\n                    const messageType = field.T();\n                    for (let i = 0; i < value.length; i++) {\n                        const val = this.message(messageType, value[i], field.name, options);\n                        assert(val !== undefined);\n                        jsonArr.push(val);\n                    }\n                    break;\n            }\n            // add converted array to json output\n            if (options.emitDefaultValues || jsonArr.length > 0 || options.emitDefaultValues)\n                jsonValue = jsonArr;\n        }\n        else {\n            switch (field.kind) {\n                case \"scalar\":\n                    jsonValue = this.scalar(field.T, value, field.name, field.opt, options.emitDefaultValues);\n                    break;\n                case \"enum\":\n                    jsonValue = this.enum(field.T(), value, field.name, field.opt, options.emitDefaultValues, options.enumAsInteger);\n                    break;\n                case \"message\":\n                    jsonValue = this.message(field.T(), value, field.name, options);\n                    break;\n            }\n        }\n        return jsonValue;\n    }\n    /**\n     * Returns `null` for google.protobuf.NullValue.\n     */\n    enum(type, value, fieldName, optional, emitDefaultValues, enumAsInteger) {\n        if (type[0] == 'google.protobuf.NullValue')\n            return null;\n        if (value === undefined) {\n            assert(optional);\n            return undefined;\n        }\n        if (value === 0 && !emitDefaultValues && !optional)\n            // we require 0 to be default value for all enums\n            return undefined;\n        assert(typeof value == 'number');\n        assert(Number.isInteger(value));\n        if (enumAsInteger || !type[1].hasOwnProperty(value))\n            // if we don't now the enum value, just return the number\n            return value;\n        if (type[2])\n            // restore the dropped prefix\n            return type[2] + type[1][value];\n        return type[1][value];\n    }\n    message(type, value, fieldName, options) {\n        if (value === undefined)\n            return options.emitDefaultValues ? null : undefined;\n        return type.internalJsonWrite(value, options);\n    }\n    scalar(type, value, fieldName, optional, emitDefaultValues) {\n        if (value === undefined) {\n            assert(optional);\n            return undefined;\n        }\n        const ed = emitDefaultValues || optional;\n        // noinspection FallThroughInSwitchStatementJS\n        switch (type) {\n            // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.\n            case ScalarType.INT32:\n            case ScalarType.SFIXED32:\n            case ScalarType.SINT32:\n                if (value === 0)\n                    return ed ? 0 : undefined;\n                assertInt32(value);\n                return value;\n            case ScalarType.FIXED32:\n            case ScalarType.UINT32:\n                if (value === 0)\n                    return ed ? 0 : undefined;\n                assertUInt32(value);\n                return value;\n            // float, double: JSON value will be a number or one of the special string values \"NaN\", \"Infinity\", and \"-Infinity\".\n            // Either numbers or strings are accepted. Exponent notation is also accepted.\n            case ScalarType.FLOAT:\n                assertFloat32(value);\n            case ScalarType.DOUBLE:\n                if (value === 0)\n                    return ed ? 0 : undefined;\n                assert(typeof value == 'number');\n                if (Number.isNaN(value))\n                    return 'NaN';\n                if (value === Number.POSITIVE_INFINITY)\n                    return 'Infinity';\n                if (value === Number.NEGATIVE_INFINITY)\n                    return '-Infinity';\n                return value;\n            // string:\n            case ScalarType.STRING:\n                if (value === \"\")\n                    return ed ? '' : undefined;\n                assert(typeof value == 'string');\n                return value;\n            // bool:\n            case ScalarType.BOOL:\n                if (value === false)\n                    return ed ? false : undefined;\n                assert(typeof value == 'boolean');\n                return value;\n            // JSON value will be a decimal string. Either numbers or strings are accepted.\n            case ScalarType.UINT64:\n            case ScalarType.FIXED64:\n                assert(typeof value == 'number' || typeof value == 'string' || typeof value == 'bigint');\n                let ulong = PbULong.from(value);\n                if (ulong.isZero() && !ed)\n                    return undefined;\n                return ulong.toString();\n            // JSON value will be a decimal string. Either numbers or strings are accepted.\n            case ScalarType.INT64:\n            case ScalarType.SFIXED64:\n            case ScalarType.SINT64:\n                assert(typeof value == 'number' || typeof value == 'string' || typeof value == 'bigint');\n                let long = PbLong.from(value);\n                if (long.isZero() && !ed)\n                    return undefined;\n                return long.toString();\n            // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.\n            // Either standard or URL-safe base64 encoding with/without paddings are accepted.\n            case ScalarType.BYTES:\n                assert(value instanceof Uint8Array);\n                if (!value.byteLength)\n                    return ed ? \"\" : undefined;\n                return base64encode(value);\n        }\n    }\n}\n", "import { LongType, ScalarType } from \"./reflection-info\";\nimport { reflectionLongConvert } from \"./reflection-long-convert\";\nimport { PbLong, PbULong } from \"./pb-long\";\n/**\n * Creates the default value for a scalar type.\n */\nexport function reflectionScalarDefault(type, longType = LongType.STRING) {\n    switch (type) {\n        case ScalarType.BOOL:\n            return false;\n        case ScalarType.UINT64:\n        case ScalarType.FIXED64:\n            return reflectionLongConvert(PbULong.ZERO, longType);\n        case ScalarType.INT64:\n        case ScalarType.SFIXED64:\n        case ScalarType.SINT64:\n            return reflectionLongConvert(PbLong.ZERO, longType);\n        case ScalarType.DOUBLE:\n        case ScalarType.FLOAT:\n            return 0.0;\n        case ScalarType.BYTES:\n            return new Uint8Array(0);\n        case ScalarType.STRING:\n            return \"\";\n        default:\n            // case ScalarType.INT32:\n            // case ScalarType.UINT32:\n            // case ScalarType.SINT32:\n            // case ScalarType.FIXED32:\n            // case ScalarType.SFIXED32:\n            return 0;\n    }\n}\n", "import { UnknownFieldHandler, WireType } from \"./binary-format-contract\";\nimport { LongType, ScalarType } from \"./reflection-info\";\nimport { reflectionLongConvert } from \"./reflection-long-convert\";\nimport { reflectionScalarDefault } from \"./reflection-scalar-default\";\n/**\n * Reads proto3 messages in binary format using reflection information.\n *\n * https://developers.google.com/protocol-buffers/docs/encoding\n */\nexport class ReflectionBinaryReader {\n    constructor(info) {\n        this.info = info;\n    }\n    prepare() {\n        var _a;\n        if (!this.fieldNoToField) {\n            const fieldsInput = (_a = this.info.fields) !== null && _a !== void 0 ? _a : [];\n            this.fieldNoToField = new Map(fieldsInput.map(field => [field.no, field]));\n        }\n    }\n    /**\n     * Reads a message from binary format into the target message.\n     *\n     * Repeated fields are appended. Map entries are added, overwriting\n     * existing keys.\n     *\n     * If a message field is already present, it will be merged with the\n     * new data.\n     */\n    read(reader, message, options, length) {\n        this.prepare();\n        const end = length === undefined ? reader.len : reader.pos + length;\n        while (reader.pos < end) {\n            // read the tag and find the field\n            const [fieldNo, wireType] = reader.tag(), field = this.fieldNoToField.get(fieldNo);\n            if (!field) {\n                let u = options.readUnknownField;\n                if (u == \"throw\")\n                    throw new Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.info.typeName}`);\n                let d = reader.skip(wireType);\n                if (u !== false)\n                    (u === true ? UnknownFieldHandler.onRead : u)(this.info.typeName, message, fieldNo, wireType, d);\n                continue;\n            }\n            // target object for the field we are reading\n            let target = message, repeated = field.repeat, localName = field.localName;\n            // if field is member of oneof ADT, use ADT as target\n            if (field.oneof) {\n                target = target[field.oneof];\n                // if other oneof member selected, set new ADT\n                if (target.oneofKind !== localName)\n                    target = message[field.oneof] = {\n                        oneofKind: localName\n                    };\n            }\n            // we have handled oneof above, we just have read the value into `target[localName]`\n            switch (field.kind) {\n                case \"scalar\":\n                case \"enum\":\n                    let T = field.kind == \"enum\" ? ScalarType.INT32 : field.T;\n                    let L = field.kind == \"scalar\" ? field.L : undefined;\n                    if (repeated) {\n                        let arr = target[localName]; // safe to assume presence of array, oneof cannot contain repeated values\n                        if (wireType == WireType.LengthDelimited && T != ScalarType.STRING && T != ScalarType.BYTES) {\n                            let e = reader.uint32() + reader.pos;\n                            while (reader.pos < e)\n                                arr.push(this.scalar(reader, T, L));\n                        }\n                        else\n                            arr.push(this.scalar(reader, T, L));\n                    }\n                    else\n                        target[localName] = this.scalar(reader, T, L);\n                    break;\n                case \"message\":\n                    if (repeated) {\n                        let arr = target[localName]; // safe to assume presence of array, oneof cannot contain repeated values\n                        let msg = field.T().internalBinaryRead(reader, reader.uint32(), options);\n                        arr.push(msg);\n                    }\n                    else\n                        target[localName] = field.T().internalBinaryRead(reader, reader.uint32(), options, target[localName]);\n                    break;\n                case \"map\":\n                    let [mapKey, mapVal] = this.mapEntry(field, reader, options);\n                    // safe to assume presence of map object, oneof cannot contain repeated values\n                    target[localName][mapKey] = mapVal;\n                    break;\n            }\n        }\n    }\n    /**\n     * Read a map field, expecting key field = 1, value field = 2\n     */\n    mapEntry(field, reader, options) {\n        let length = reader.uint32();\n        let end = reader.pos + length;\n        let key = undefined; // javascript only allows number or string for object properties\n        let val = undefined;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case 1:\n                    if (field.K == ScalarType.BOOL)\n                        key = reader.bool().toString();\n                    else\n                        // long types are read as string, number types are okay as number\n                        key = this.scalar(reader, field.K, LongType.STRING);\n                    break;\n                case 2:\n                    switch (field.V.kind) {\n                        case \"scalar\":\n                            val = this.scalar(reader, field.V.T, field.V.L);\n                            break;\n                        case \"enum\":\n                            val = reader.int32();\n                            break;\n                        case \"message\":\n                            val = field.V.T().internalBinaryRead(reader, reader.uint32(), options);\n                            break;\n                    }\n                    break;\n                default:\n                    throw new Error(`Unknown field ${fieldNo} (wire type ${wireType}) in map entry for ${this.info.typeName}#${field.name}`);\n            }\n        }\n        if (key === undefined) {\n            let keyRaw = reflectionScalarDefault(field.K);\n            key = field.K == ScalarType.BOOL ? keyRaw.toString() : keyRaw;\n        }\n        if (val === undefined)\n            switch (field.V.kind) {\n                case \"scalar\":\n                    val = reflectionScalarDefault(field.V.T, field.V.L);\n                    break;\n                case \"enum\":\n                    val = 0;\n                    break;\n                case \"message\":\n                    val = field.V.T().create();\n                    break;\n            }\n        return [key, val];\n    }\n    scalar(reader, type, longType) {\n        switch (type) {\n            case ScalarType.INT32:\n                return reader.int32();\n            case ScalarType.STRING:\n                return reader.string();\n            case ScalarType.BOOL:\n                return reader.bool();\n            case ScalarType.DOUBLE:\n                return reader.double();\n            case ScalarType.FLOAT:\n                return reader.float();\n            case ScalarType.INT64:\n                return reflectionLongConvert(reader.int64(), longType);\n            case ScalarType.UINT64:\n                return reflectionLongConvert(reader.uint64(), longType);\n            case ScalarType.FIXED64:\n                return reflectionLongConvert(reader.fixed64(), longType);\n            case ScalarType.FIXED32:\n                return reader.fixed32();\n            case ScalarType.BYTES:\n                return reader.bytes();\n            case ScalarType.UINT32:\n                return reader.uint32();\n            case ScalarType.SFIXED32:\n                return reader.sfixed32();\n            case ScalarType.SFIXED64:\n                return reflectionLongConvert(reader.sfixed64(), longType);\n            case ScalarType.SINT32:\n                return reader.sint32();\n            case ScalarType.SINT64:\n                return reflectionLongConvert(reader.sint64(), longType);\n        }\n    }\n}\n", "import { UnknownFieldHandler, WireType } from \"./binary-format-contract\";\nimport { RepeatType, ScalarType } from \"./reflection-info\";\nimport { assert } from \"./assert\";\nimport { PbLong, PbULong } from \"./pb-long\";\n/**\n * Writes proto3 messages in binary format using reflection information.\n *\n * https://developers.google.com/protocol-buffers/docs/encoding\n */\nexport class ReflectionBinaryWriter {\n    constructor(info) {\n        this.info = info;\n    }\n    prepare() {\n        if (!this.fields) {\n            const fieldsInput = this.info.fields ? this.info.fields.concat() : [];\n            this.fields = fieldsInput.sort((a, b) => a.no - b.no);\n        }\n    }\n    /**\n     * Writes the message to binary format.\n     */\n    write(message, writer, options) {\n        this.prepare();\n        for (const field of this.fields) {\n            let value, // this will be our field value, whether it is member of a oneof or not\n            emitDefault, // whether we emit the default value (only true for oneof members)\n            repeated = field.repeat, localName = field.localName;\n            // handle oneof ADT\n            if (field.oneof) {\n                const group = message[field.oneof];\n                if (group.oneofKind !== localName)\n                    continue; // if field is not selected, skip\n                value = group[localName];\n                emitDefault = true;\n            }\n            else {\n                value = message[localName];\n                emitDefault = false;\n            }\n            // we have handled oneof above. we just have to honor `emitDefault`.\n            switch (field.kind) {\n                case \"scalar\":\n                case \"enum\":\n                    let T = field.kind == \"enum\" ? ScalarType.INT32 : field.T;\n                    if (repeated) {\n                        assert(Array.isArray(value));\n                        if (repeated == RepeatType.PACKED)\n                            this.packed(writer, T, field.no, value);\n                        else\n                            for (const item of value)\n                                this.scalar(writer, T, field.no, item, true);\n                    }\n                    else if (value === undefined)\n                        assert(field.opt);\n                    else\n                        this.scalar(writer, T, field.no, value, emitDefault || field.opt);\n                    break;\n                case \"message\":\n                    if (repeated) {\n                        assert(Array.isArray(value));\n                        for (const item of value)\n                            this.message(writer, options, field.T(), field.no, item);\n                    }\n                    else {\n                        this.message(writer, options, field.T(), field.no, value);\n                    }\n                    break;\n                case \"map\":\n                    assert(typeof value == 'object' && value !== null);\n                    for (const [key, val] of Object.entries(value))\n                        this.mapEntry(writer, options, field, key, val);\n                    break;\n            }\n        }\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u === true ? UnknownFieldHandler.onWrite : u)(this.info.typeName, message, writer);\n    }\n    mapEntry(writer, options, field, key, value) {\n        writer.tag(field.no, WireType.LengthDelimited);\n        writer.fork();\n        // javascript only allows number or string for object properties\n        // we convert from our representation to the protobuf type\n        let keyValue = key;\n        switch (field.K) {\n            case ScalarType.INT32:\n            case ScalarType.FIXED32:\n            case ScalarType.UINT32:\n            case ScalarType.SFIXED32:\n            case ScalarType.SINT32:\n                keyValue = Number.parseInt(key);\n                break;\n            case ScalarType.BOOL:\n                assert(key == 'true' || key == 'false');\n                keyValue = key == 'true';\n                break;\n        }\n        // write key, expecting key field number = 1\n        this.scalar(writer, field.K, 1, keyValue, true);\n        // write value, expecting value field number = 2\n        switch (field.V.kind) {\n            case 'scalar':\n                this.scalar(writer, field.V.T, 2, value, true);\n                break;\n            case 'enum':\n                this.scalar(writer, ScalarType.INT32, 2, value, true);\n                break;\n            case 'message':\n                this.message(writer, options, field.V.T(), 2, value);\n                break;\n        }\n        writer.join();\n    }\n    message(writer, options, handler, fieldNo, value) {\n        if (value === undefined)\n            return;\n        handler.internalBinaryWrite(value, writer.tag(fieldNo, WireType.LengthDelimited).fork(), options);\n        writer.join();\n    }\n    /**\n     * Write a single scalar value.\n     */\n    scalar(writer, type, fieldNo, value, emitDefault) {\n        let [wireType, method, isDefault] = this.scalarInfo(type, value);\n        if (!isDefault || emitDefault) {\n            writer.tag(fieldNo, wireType);\n            writer[method](value);\n        }\n    }\n    /**\n     * Write an array of scalar values in packed format.\n     */\n    packed(writer, type, fieldNo, value) {\n        if (!value.length)\n            return;\n        assert(type !== ScalarType.BYTES && type !== ScalarType.STRING);\n        // write tag\n        writer.tag(fieldNo, WireType.LengthDelimited);\n        // begin length-delimited\n        writer.fork();\n        // write values without tags\n        let [, method,] = this.scalarInfo(type);\n        for (let i = 0; i < value.length; i++)\n            writer[method](value[i]);\n        // end length delimited\n        writer.join();\n    }\n    /**\n     * Get information for writing a scalar value.\n     *\n     * Returns tuple:\n     * [0]: appropriate WireType\n     * [1]: name of the appropriate method of IBinaryWriter\n     * [2]: whether the given value is a default value\n     *\n     * If argument `value` is omitted, [2] is always false.\n     */\n    scalarInfo(type, value) {\n        let t = WireType.Varint;\n        let m;\n        let i = value === undefined;\n        let d = value === 0;\n        switch (type) {\n            case ScalarType.INT32:\n                m = \"int32\";\n                break;\n            case ScalarType.STRING:\n                d = i || !value.length;\n                t = WireType.LengthDelimited;\n                m = \"string\";\n                break;\n            case ScalarType.BOOL:\n                d = value === false;\n                m = \"bool\";\n                break;\n            case ScalarType.UINT32:\n                m = \"uint32\";\n                break;\n            case ScalarType.DOUBLE:\n                t = WireType.Bit64;\n                m = \"double\";\n                break;\n            case ScalarType.FLOAT:\n                t = WireType.Bit32;\n                m = \"float\";\n                break;\n            case ScalarType.INT64:\n                d = i || PbLong.from(value).isZero();\n                m = \"int64\";\n                break;\n            case ScalarType.UINT64:\n                d = i || PbULong.from(value).isZero();\n                m = \"uint64\";\n                break;\n            case ScalarType.FIXED64:\n                d = i || PbULong.from(value).isZero();\n                t = WireType.Bit64;\n                m = \"fixed64\";\n                break;\n            case ScalarType.BYTES:\n                d = i || !value.byteLength;\n                t = WireType.LengthDelimited;\n                m = \"bytes\";\n                break;\n            case ScalarType.FIXED32:\n                t = WireType.Bit32;\n                m = \"fixed32\";\n                break;\n            case ScalarType.SFIXED32:\n                t = WireType.Bit32;\n                m = \"sfixed32\";\n                break;\n            case ScalarType.SFIXED64:\n                d = i || PbLong.from(value).isZero();\n                t = WireType.Bit64;\n                m = \"sfixed64\";\n                break;\n            case ScalarType.SINT32:\n                m = \"sint32\";\n                break;\n            case ScalarType.SINT64:\n                d = i || PbLong.from(value).isZero();\n                m = \"sint64\";\n                break;\n        }\n        return [t, m, i || d];\n    }\n}\n", "import { reflectionScalarDefault } from \"./reflection-scalar-default\";\nimport { MESSAGE_TYPE } from './message-type-contract';\n/**\n * Creates an instance of the generic message, using the field\n * information.\n */\nexport function reflectionCreate(type) {\n    const msg = {};\n    Object.defineProperty(msg, MESSAGE_TYPE, { enumerable: false, value: type });\n    for (let field of type.fields) {\n        let name = field.localName;\n        if (field.opt)\n            continue;\n        if (field.oneof)\n            msg[field.oneof] = { oneofKind: undefined };\n        else if (field.repeat)\n            msg[name] = [];\n        else\n            switch (field.kind) {\n                case \"scalar\":\n                    msg[name] = reflectionScalarDefault(field.T, field.L);\n                    break;\n                case \"enum\":\n                    // we require 0 to be default value for all enums\n                    msg[name] = 0;\n                    break;\n                case \"map\":\n                    msg[name] = {};\n                    break;\n            }\n    }\n    return msg;\n}\n", "/**\n * Copy partial data into the target message.\n *\n * Replaces fields in the target with the fields from the\n * (partial) source.\n *\n * Omitted fields are not replaced.\n * Copies all values.\n * A default value in the source will replace a value in the target.\n *\n * Message fields are recursively merged (by calling `mergePartial()`\n * of the responsible message handler). Map and repeated fields\n * are simply overwritten, not appended or merged.\n */\nexport function reflectionMergePartial(info, target, source) {\n    let fieldValue, // the field value we are working with\n    input = source, output; // where we want our field value to go\n    for (let field of info.fields) {\n        let name = field.localName;\n        if (field.oneof) {\n            const group = input[field.oneof]; // this is the oneof`s group in the source\n            if (group == undefined) { // the user is free to omit\n                continue; // we skip this field, and all other members too\n            }\n            fieldValue = group[name]; // our value comes from the the oneof group of the source\n            output = target[field.oneof]; // and our output is the oneof group of the target\n            output.oneofKind = group.oneofKind; // always update discriminator\n            if (fieldValue == undefined) {\n                delete output[name]; // remove any existing value\n                continue; // skip further work on field\n            }\n        }\n        else {\n            fieldValue = input[name]; // we are using the source directly\n            output = target; // we want our field value to go directly into the target\n            if (fieldValue == undefined) {\n                continue; // skip further work on field, existing value is used as is\n            }\n        }\n        // now we just work with `fieldValue` and `output` to merge the value\n        switch (field.kind) {\n            case \"scalar\":\n            case \"enum\":\n                if (field.repeat)\n                    output[name] = fieldValue.concat(); // elements are not reference types\n                else\n                    output[name] = fieldValue; // not a reference type\n                break;\n            case \"message\":\n                let T = field.T();\n                if (field.repeat)\n                    for (let i = 0; i < fieldValue.length; i++)\n                        output[name][i] = T.create(fieldValue[i]);\n                else if (output[name] === undefined)\n                    output[name] = T.create(fieldValue); // nothing to merge with\n                else\n                    T.mergePartial(output[name], fieldValue);\n                break;\n            case \"map\":\n                // Map and repeated fields are simply overwritten, not appended or merged\n                switch (field.V.kind) {\n                    case \"scalar\":\n                    case \"enum\":\n                        Object.assign(output[name], fieldValue); // elements are not reference types\n                        break;\n                    case \"message\":\n                        let T = field.V.T();\n                        for (let k of Object.keys(fieldValue))\n                            output[name][k] = T.create(fieldValue[k]);\n                        break;\n                }\n                break;\n        }\n    }\n}\n", "import { ScalarType } from \"./reflection-info\";\n/**\n * Determines whether two message of the same type have the same field values.\n * Checks for deep equality, traversing repeated fields, oneof groups, maps\n * and messages recursively.\n * Will also return true if both messages are `undefined`.\n */\nexport function reflectionEquals(info, a, b) {\n    if (a === b)\n        return true;\n    if (!a || !b)\n        return false;\n    for (let field of info.fields) {\n        let localName = field.localName;\n        let val_a = field.oneof ? a[field.oneof][localName] : a[localName];\n        let val_b = field.oneof ? b[field.oneof][localName] : b[localName];\n        switch (field.kind) {\n            case \"enum\":\n            case \"scalar\":\n                let t = field.kind == \"enum\" ? ScalarType.INT32 : field.T;\n                if (!(field.repeat\n                    ? repeatedPrimitiveEq(t, val_a, val_b)\n                    : primitiveEq(t, val_a, val_b)))\n                    return false;\n                break;\n            case \"map\":\n                if (!(field.V.kind == \"message\"\n                    ? repeatedMsgEq(field.V.T(), objectValues(val_a), objectValues(val_b))\n                    : repeatedPrimitiveEq(field.V.kind == \"enum\" ? ScalarType.INT32 : field.V.T, objectValues(val_a), objectValues(val_b))))\n                    return false;\n                break;\n            case \"message\":\n                let T = field.T();\n                if (!(field.repeat\n                    ? repeatedMsgEq(T, val_a, val_b)\n                    : T.equals(val_a, val_b)))\n                    return false;\n                break;\n        }\n    }\n    return true;\n}\nconst objectValues = Object.values;\nfunction primitiveEq(type, a, b) {\n    if (a === b)\n        return true;\n    if (type !== ScalarType.BYTES)\n        return false;\n    let ba = a;\n    let bb = b;\n    if (ba.length !== bb.length)\n        return false;\n    for (let i = 0; i < ba.length; i++)\n        if (ba[i] != bb[i])\n            return false;\n    return true;\n}\nfunction repeatedPrimitiveEq(type, a, b) {\n    if (a.length !== b.length)\n        return false;\n    for (let i = 0; i < a.length; i++)\n        if (!primitiveEq(type, a[i], b[i]))\n            return false;\n    return true;\n}\nfunction repeatedMsgEq(type, a, b) {\n    if (a.length !== b.length)\n        return false;\n    for (let i = 0; i < a.length; i++)\n        if (!type.equals(a[i], b[i]))\n            return false;\n    return true;\n}\n", "import { normalizeFieldInfo } from \"./reflection-info\";\nimport { ReflectionTypeCheck } from \"./reflection-type-check\";\nimport { ReflectionJsonReader } from \"./reflection-json-reader\";\nimport { ReflectionJsonWriter } from \"./reflection-json-writer\";\nimport { ReflectionBinaryReader } from \"./reflection-binary-reader\";\nimport { ReflectionBinaryWriter } from \"./reflection-binary-writer\";\nimport { reflectionCreate } from \"./reflection-create\";\nimport { reflectionMergePartial } from \"./reflection-merge-partial\";\nimport { typeofJsonValue } from \"./json-typings\";\nimport { jsonReadOptions, jsonWriteOptions, } from \"./json-format-contract\";\nimport { reflectionEquals } from \"./reflection-equals\";\nimport { binaryWriteOptions } from \"./binary-writer\";\nimport { binaryReadOptions } from \"./binary-reader\";\n/**\n * This standard message type provides reflection-based\n * operations to work with a message.\n */\nexport class MessageType {\n    constructor(name, fields, options) {\n        this.defaultCheckDepth = 16;\n        this.typeName = name;\n        this.fields = fields.map(normalizeFieldInfo);\n        this.options = options !== null && options !== void 0 ? options : {};\n        this.refTypeCheck = new ReflectionTypeCheck(this);\n        this.refJsonReader = new ReflectionJsonReader(this);\n        this.refJsonWriter = new ReflectionJsonWriter(this);\n        this.refBinReader = new ReflectionBinaryReader(this);\n        this.refBinWriter = new ReflectionBinaryWriter(this);\n    }\n    create(value) {\n        let message = reflectionCreate(this);\n        if (value !== undefined) {\n            reflectionMergePartial(this, message, value);\n        }\n        return message;\n    }\n    /**\n     * Clone the message.\n     *\n     * Unknown fields are discarded.\n     */\n    clone(message) {\n        let copy = this.create();\n        reflectionMergePartial(this, copy, message);\n        return copy;\n    }\n    /**\n     * Determines whether two message of the same type have the same field values.\n     * Checks for deep equality, traversing repeated fields, oneof groups, maps\n     * and messages recursively.\n     * Will also return true if both messages are `undefined`.\n     */\n    equals(a, b) {\n        return reflectionEquals(this, a, b);\n    }\n    /**\n     * Is the given value assignable to our message type\n     * and contains no [excess properties](https://www.typescriptlang.org/docs/handbook/interfaces.html#excess-property-checks)?\n     */\n    is(arg, depth = this.defaultCheckDepth) {\n        return this.refTypeCheck.is(arg, depth, false);\n    }\n    /**\n     * Is the given value assignable to our message type,\n     * regardless of [excess properties](https://www.typescriptlang.org/docs/handbook/interfaces.html#excess-property-checks)?\n     */\n    isAssignable(arg, depth = this.defaultCheckDepth) {\n        return this.refTypeCheck.is(arg, depth, true);\n    }\n    /**\n     * Copy partial data into the target message.\n     */\n    mergePartial(target, source) {\n        reflectionMergePartial(this, target, source);\n    }\n    /**\n     * Create a new message from binary format.\n     */\n    fromBinary(data, options) {\n        let opt = binaryReadOptions(options);\n        return this.internalBinaryRead(opt.readerFactory(data), data.byteLength, opt);\n    }\n    /**\n     * Read a new message from a JSON value.\n     */\n    fromJson(json, options) {\n        return this.internalJsonRead(json, jsonReadOptions(options));\n    }\n    /**\n     * Read a new message from a JSON string.\n     * This is equivalent to `T.fromJson(JSON.parse(json))`.\n     */\n    fromJsonString(json, options) {\n        let value = JSON.parse(json);\n        return this.fromJson(value, options);\n    }\n    /**\n     * Write the message to canonical JSON value.\n     */\n    toJson(message, options) {\n        return this.internalJsonWrite(message, jsonWriteOptions(options));\n    }\n    /**\n     * Convert the message to canonical JSON string.\n     * This is equivalent to `JSON.stringify(T.toJson(t))`\n     */\n    toJsonString(message, options) {\n        var _a;\n        let value = this.toJson(message, options);\n        return JSON.stringify(value, null, (_a = options === null || options === void 0 ? void 0 : options.prettySpaces) !== null && _a !== void 0 ? _a : 0);\n    }\n    /**\n     * Write the message to binary format.\n     */\n    toBinary(message, options) {\n        let opt = binaryWriteOptions(options);\n        return this.internalBinaryWrite(message, opt.writerFactory(), opt).finish();\n    }\n    /**\n     * This is an internal method. If you just want to read a message from\n     * JSON, use `fromJson()` or `fromJsonString()`.\n     *\n     * Reads JSON value and merges the fields into the target\n     * according to protobuf rules. If the target is omitted,\n     * a new instance is created first.\n     */\n    internalJsonRead(json, options, target) {\n        if (json !== null && typeof json == \"object\" && !Array.isArray(json)) {\n            let message = target !== null && target !== void 0 ? target : this.create();\n            this.refJsonReader.read(json, message, options);\n            return message;\n        }\n        throw new Error(`Unable to parse message ${this.typeName} from JSON ${typeofJsonValue(json)}.`);\n    }\n    /**\n     * This is an internal method. If you just want to write a message\n     * to JSON, use `toJson()` or `toJsonString().\n     *\n     * Writes JSON value and returns it.\n     */\n    internalJsonWrite(message, options) {\n        return this.refJsonWriter.write(message, options);\n    }\n    /**\n     * This is an internal method. If you just want to write a message\n     * in binary format, use `toBinary()`.\n     *\n     * Serializes the message in binary format and appends it to the given\n     * writer. Returns passed writer.\n     */\n    internalBinaryWrite(message, writer, options) {\n        this.refBinWriter.write(message, writer, options);\n        return writer;\n    }\n    /**\n     * This is an internal method. If you just want to read a message from\n     * binary data, use `fromBinary()`.\n     *\n     * Reads data from binary format and merges the fields into\n     * the target according to protobuf rules. If the target is\n     * omitted, a new instance is created first.\n     */\n    internalBinaryRead(reader, length, options, target) {\n        let message = target !== null && target !== void 0 ? target : this.create();\n        this.refBinReader.read(reader, message, options, length);\n        return message;\n    }\n}\n", "// @generated by protobuf-ts 2.3.0\n// @generated from protobuf file \"errors/v1/errors.proto\" (package \"errors.v1\", syntax proto3)\n// tslint:disable\nimport type { BinaryWriteOptions } from '@protobuf-ts/runtime';\nimport type { IBinaryWriter } from '@protobuf-ts/runtime';\nimport { WireType } from '@protobuf-ts/runtime';\nimport type { BinaryReadOptions } from '@protobuf-ts/runtime';\nimport type { IBinaryReader } from '@protobuf-ts/runtime';\nimport { UnknownFieldHandler } from '@protobuf-ts/runtime';\nimport type { PartialMessage } from '@protobuf-ts/runtime';\nimport { reflectionMergePartial } from '@protobuf-ts/runtime';\nimport { MESSAGE_TYPE } from '@protobuf-ts/runtime';\nimport { MessageType } from '@protobuf-ts/runtime';\n/**\n * @generated from protobuf message errors.v1.BasicError\n */\nexport interface BasicError {\n  /**\n   * @generated from protobuf field: string message = 1;\n   */\n  message: string;\n  /**\n   * @generated from protobuf field: errors.v1.BasicError.BasicErrorCode code = 2;\n   */\n  code: BasicError_BasicErrorCode;\n}\n/**\n * @generated from protobuf enum errors.v1.BasicError.BasicErrorCode\n */\nexport enum BasicError_BasicErrorCode {\n  /**\n   * @generated from protobuf enum value: BASIC_ERROR_CODE_UNSPECIFIED = 0;\n   */\n  UNSPECIFIED = 0,\n  /**\n   * @generated from protobuf enum value: BASIC_ERROR_CODE_BAD_REQUEST = 1;\n   */\n  BAD_REQUEST = 1,\n  /**\n   * @generated from protobuf enum value: BASIC_ERROR_CODE_UNAUTHENTICATED = 2;\n   */\n  UNAUTHENTICATED = 2,\n  /**\n   * @generated from protobuf enum value: BASIC_ERROR_CODE_NOT_FOUND = 3;\n   */\n  NOT_FOUND = 3,\n  /**\n   * @generated from protobuf enum value: BASIC_ERROR_CODE_INTERNAL = 4;\n   */\n  INTERNAL = 4,\n  /**\n   * @generated from protobuf enum value: BASIC_ERROR_CODE_UNKNOWN = 5;\n   */\n  UNKNOWN = 5,\n}\n// @generated message type with reflection information, may provide speed optimized methods\nclass BasicError$Type extends MessageType<BasicError> {\n  constructor() {\n    super('errors.v1.BasicError', [\n      { no: 1, name: 'message', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },\n      {\n        no: 2,\n        name: 'code',\n        kind: 'enum',\n        T: () => [\n          'errors.v1.BasicError.BasicErrorCode',\n          BasicError_BasicErrorCode,\n          'BASIC_ERROR_CODE_',\n        ],\n      },\n    ]);\n  }\n  create(value?: PartialMessage<BasicError>): BasicError {\n    const message = { message: '', code: 0 };\n    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {\n      enumerable: false,\n      value: this,\n    });\n    if (value !== undefined)\n      reflectionMergePartial<BasicError>(this, message, value);\n    return message;\n  }\n  internalBinaryRead(\n    reader: IBinaryReader,\n    length: number,\n    options: BinaryReadOptions,\n    target?: BasicError,\n  ): BasicError {\n    let message = target ?? this.create(),\n      end = reader.pos + length;\n    while (reader.pos < end) {\n      let [fieldNo, wireType] = reader.tag();\n      switch (fieldNo) {\n        case /* string message */ 1:\n          message.message = reader.string();\n          break;\n        case /* errors.v1.BasicError.BasicErrorCode code */ 2:\n          message.code = reader.int32();\n          break;\n        default:\n          let u = options.readUnknownField;\n          if (u === 'throw')\n            throw new globalThis.Error(\n              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,\n            );\n          let d = reader.skip(wireType);\n          if (u !== false)\n            (u === true ? UnknownFieldHandler.onRead : u)(\n              this.typeName,\n              message,\n              fieldNo,\n              wireType,\n              d,\n            );\n      }\n    }\n    return message;\n  }\n  internalBinaryWrite(\n    message: BasicError,\n    writer: IBinaryWriter,\n    options: BinaryWriteOptions,\n  ): IBinaryWriter {\n    /* string message = 1; */\n    if (message.message !== '')\n      writer.tag(1, WireType.LengthDelimited).string(message.message);\n    /* errors.v1.BasicError.BasicErrorCode code = 2; */\n    if (message.code !== 0) writer.tag(2, WireType.Varint).int32(message.code);\n    let u = options.writeUnknownFields;\n    if (u !== false)\n      (u == true ? UnknownFieldHandler.onWrite : u)(\n        this.typeName,\n        message,\n        writer,\n      );\n    return writer;\n  }\n}\n/**\n * @generated MessageType for protobuf message errors.v1.BasicError\n */\nexport const BasicError = new BasicError$Type();\n", "// @generated by protobuf-ts 2.3.0\n// @generated from protobuf file \"pings/v1/pings.proto\" (package \"pings.v1\", syntax proto3)\n// tslint:disable\nimport type { BinaryWriteOptions } from '@protobuf-ts/runtime';\nimport type { IBinaryWriter } from '@protobuf-ts/runtime';\nimport { WireType } from '@protobuf-ts/runtime';\nimport type { BinaryReadOptions } from '@protobuf-ts/runtime';\nimport type { IBinaryReader } from '@protobuf-ts/runtime';\nimport { UnknownFieldHandler } from '@protobuf-ts/runtime';\nimport type { PartialMessage } from '@protobuf-ts/runtime';\nimport { reflectionMergePartial } from '@protobuf-ts/runtime';\nimport { MESSAGE_TYPE } from '@protobuf-ts/runtime';\nimport { MessageType } from '@protobuf-ts/runtime';\nimport { BasicError } from '../../errors/v1/errors';\n/**\n * @generated from protobuf message pings.v1.Ping\n */\nexport interface Ping {\n  /**\n   * @generated from protobuf field: string ping_id = 1;\n   */\n  pingId: string;\n  /**\n   * @generated from protobuf field: string message = 2;\n   */\n  message: string;\n}\n/**\n * @generated from protobuf message pings.v1.GetPingRequest\n */\nexport interface GetPingRequest {\n  /**\n   * @generated from protobuf field: string ping_id = 1;\n   */\n  pingId: string;\n}\n/**\n * @generated from protobuf message pings.v1.GetPingResponse\n */\nexport interface GetPingResponse {\n  /**\n   * @generated from protobuf oneof: response\n   */\n  response:\n    | {\n        oneofKind: 'ok';\n        /**\n         * @generated from protobuf field: pings.v1.Ping ok = 1;\n         */\n        ok: Ping;\n      }\n    | {\n        oneofKind: 'error';\n        /**\n         * @generated from protobuf field: errors.v1.BasicError error = 2;\n         */\n        error: BasicError;\n      }\n    | {\n        oneofKind: undefined;\n      };\n}\n// @generated message type with reflection information, may provide speed optimized methods\nclass Ping$Type extends MessageType<Ping> {\n  constructor() {\n    super('pings.v1.Ping', [\n      { no: 1, name: 'ping_id', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },\n      { no: 2, name: 'message', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },\n    ]);\n  }\n  create(value?: PartialMessage<Ping>): Ping {\n    const message = { pingId: '', message: '' };\n    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {\n      enumerable: false,\n      value: this,\n    });\n    if (value !== undefined) reflectionMergePartial<Ping>(this, message, value);\n    return message;\n  }\n  internalBinaryRead(\n    reader: IBinaryReader,\n    length: number,\n    options: BinaryReadOptions,\n    target?: Ping,\n  ): Ping {\n    let message = target ?? this.create(),\n      end = reader.pos + length;\n    while (reader.pos < end) {\n      let [fieldNo, wireType] = reader.tag();\n      switch (fieldNo) {\n        case /* string ping_id */ 1:\n          message.pingId = reader.string();\n          break;\n        case /* string message */ 2:\n          message.message = reader.string();\n          break;\n        default:\n          let u = options.readUnknownField;\n          if (u === 'throw')\n            throw new globalThis.Error(\n              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,\n            );\n          let d = reader.skip(wireType);\n          if (u !== false)\n            (u === true ? UnknownFieldHandler.onRead : u)(\n              this.typeName,\n              message,\n              fieldNo,\n              wireType,\n              d,\n            );\n      }\n    }\n    return message;\n  }\n  internalBinaryWrite(\n    message: Ping,\n    writer: IBinaryWriter,\n    options: BinaryWriteOptions,\n  ): IBinaryWriter {\n    /* string ping_id = 1; */\n    if (message.pingId !== '')\n      writer.tag(1, WireType.LengthDelimited).string(message.pingId);\n    /* string message = 2; */\n    if (message.message !== '')\n      writer.tag(2, WireType.LengthDelimited).string(message.message);\n    let u = options.writeUnknownFields;\n    if (u !== false)\n      (u == true ? UnknownFieldHandler.onWrite : u)(\n        this.typeName,\n        message,\n        writer,\n      );\n    return writer;\n  }\n}\n/**\n * @generated MessageType for protobuf message pings.v1.Ping\n */\nexport const Ping = new Ping$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass GetPingRequest$Type extends MessageType<GetPingRequest> {\n  constructor() {\n    super('pings.v1.GetPingRequest', [\n      { no: 1, name: 'ping_id', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },\n    ]);\n  }\n  create(value?: PartialMessage<GetPingRequest>): GetPingRequest {\n    const message = { pingId: '' };\n    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {\n      enumerable: false,\n      value: this,\n    });\n    if (value !== undefined)\n      reflectionMergePartial<GetPingRequest>(this, message, value);\n    return message;\n  }\n  internalBinaryRead(\n    reader: IBinaryReader,\n    length: number,\n    options: BinaryReadOptions,\n    target?: GetPingRequest,\n  ): GetPingRequest {\n    let message = target ?? this.create(),\n      end = reader.pos + length;\n    while (reader.pos < end) {\n      let [fieldNo, wireType] = reader.tag();\n      switch (fieldNo) {\n        case /* string ping_id */ 1:\n          message.pingId = reader.string();\n          break;\n        default:\n          let u = options.readUnknownField;\n          if (u === 'throw')\n            throw new globalThis.Error(\n              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,\n            );\n          let d = reader.skip(wireType);\n          if (u !== false)\n            (u === true ? UnknownFieldHandler.onRead : u)(\n              this.typeName,\n              message,\n              fieldNo,\n              wireType,\n              d,\n            );\n      }\n    }\n    return message;\n  }\n  internalBinaryWrite(\n    message: GetPingRequest,\n    writer: IBinaryWriter,\n    options: BinaryWriteOptions,\n  ): IBinaryWriter {\n    /* string ping_id = 1; */\n    if (message.pingId !== '')\n      writer.tag(1, WireType.LengthDelimited).string(message.pingId);\n    let u = options.writeUnknownFields;\n    if (u !== false)\n      (u == true ? UnknownFieldHandler.onWrite : u)(\n        this.typeName,\n        message,\n        writer,\n      );\n    return writer;\n  }\n}\n/**\n * @generated MessageType for protobuf message pings.v1.GetPingRequest\n */\nexport const GetPingRequest = new GetPingRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass GetPingResponse$Type extends MessageType<GetPingResponse> {\n  constructor() {\n    super('pings.v1.GetPingResponse', [\n      { no: 1, name: 'ok', kind: 'message', oneof: 'response', T: () => Ping },\n      {\n        no: 2,\n        name: 'error',\n        kind: 'message',\n        oneof: 'response',\n        T: () => BasicError,\n      },\n    ]);\n  }\n  create(value?: PartialMessage<GetPingResponse>): GetPingResponse {\n    const message = { response: { oneofKind: undefined } };\n    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {\n      enumerable: false,\n      value: this,\n    });\n    if (value !== undefined)\n      reflectionMergePartial<GetPingResponse>(this, message, value);\n    return message;\n  }\n  internalBinaryRead(\n    reader: IBinaryReader,\n    length: number,\n    options: BinaryReadOptions,\n    target?: GetPingResponse,\n  ): GetPingResponse {\n    let message = target ?? this.create(),\n      end = reader.pos + length;\n    while (reader.pos < end) {\n      let [fieldNo, wireType] = reader.tag();\n      switch (fieldNo) {\n        case /* pings.v1.Ping ok */ 1:\n          message.response = {\n            oneofKind: 'ok',\n            ok: Ping.internalBinaryRead(\n              reader,\n              reader.uint32(),\n              options,\n              (message.response as any).ok,\n            ),\n          };\n          break;\n        case /* errors.v1.BasicError error */ 2:\n          message.response = {\n            oneofKind: 'error',\n            error: BasicError.internalBinaryRead(\n              reader,\n              reader.uint32(),\n              options,\n              (message.response as any).error,\n            ),\n          };\n          break;\n        default:\n          let u = options.readUnknownField;\n          if (u === 'throw')\n            throw new globalThis.Error(\n              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,\n            );\n          let d = reader.skip(wireType);\n          if (u !== false)\n            (u === true ? UnknownFieldHandler.onRead : u)(\n              this.typeName,\n              message,\n              fieldNo,\n              wireType,\n              d,\n            );\n      }\n    }\n    return message;\n  }\n  internalBinaryWrite(\n    message: GetPingResponse,\n    writer: IBinaryWriter,\n    options: BinaryWriteOptions,\n  ): IBinaryWriter {\n    /* pings.v1.Ping ok = 1; */\n    if (message.response.oneofKind === 'ok')\n      Ping.internalBinaryWrite(\n        message.response.ok,\n        writer.tag(1, WireType.LengthDelimited).fork(),\n        options,\n      ).join();\n    /* errors.v1.BasicError error = 2; */\n    if (message.response.oneofKind === 'error')\n      BasicError.internalBinaryWrite(\n        message.response.error,\n        writer.tag(2, WireType.LengthDelimited).fork(),\n        options,\n      ).join();\n    let u = options.writeUnknownFields;\n    if (u !== false)\n      (u == true ? UnknownFieldHandler.onWrite : u)(\n        this.typeName,\n        message,\n        writer,\n      );\n    return writer;\n  }\n}\n/**\n * @generated MessageType for protobuf message pings.v1.GetPingResponse\n */\nexport const GetPingResponse = new GetPingResponse$Type();\n", "export const enum MediaType {\n  APPLICATION_OCTET_STREAM = 'application/octet-stream',\n  APPLICATION_JSON = 'application/json',\n}\n\nexport const enum Headers {\n  CONTENT_TYPE = 'content-type',\n  ACCEPT = 'accept',\n}\n\nexport const enum MessageFormat {\n  JSON = 'JSON',\n  PROTOBUF = 'PROTOBUF',\n}\n\nexport function messageFormatToMediaType(messageFormat: MessageFormat) {\n  if (messageFormat === MessageFormat.PROTOBUF) {\n    return MediaType.APPLICATION_OCTET_STREAM;\n  }\n  return MediaType.APPLICATION_JSON;\n}\n", "import { Headers, MediaType, MessageFormat } from './types';\n\nexport function getResponseFormat(request: Request): MessageFormat {\n  const acceptHeader = request.headers.get(Headers.ACCEPT);\n  return mediaTypeToMessageFormat(acceptHeader);\n}\n\nexport function getRequestFormat(request: Request): MessageFormat {\n  const contentType = request.headers.get(Headers.CONTENT_TYPE);\n  return mediaTypeToMessageFormat(contentType);\n}\n\nfunction mediaTypeToMessageFormat(contentType: string | null) {\n  if (contentType === MediaType.APPLICATION_OCTET_STREAM) {\n    return MessageFormat.PROTOBUF;\n  }\n  return MessageFormat.JSON;\n}\n", "export function isNullOrUndefined(val: unknown): val is null | undefined {\n  return val === null || val === undefined;\n}\n\nexport function isNotNullOrUndefined<T>(val: T | null | undefined): val is T {\n  return val !== null && val !== undefined;\n}\n", "import { MessageType } from '@protobuf-ts/runtime';\nimport { Logger } from 'workers-loki-logger';\nimport { MessageFormat } from '../http/types';\nimport { isNotNullOrUndefined } from '../lib';\n\nexport interface TestingContext {\n  test: true;\n}\n\nexport function isTestingContext<T extends {}>(\n  context: T | undefined | null,\n): context is T & TestingContext {\n  return isNotNullOrUndefined(context) && context.hasOwnProperty('test');\n}\n\nexport interface AuthenticatedContext {\n  user: {\n    userId: string;\n    roles: Set<string>;\n  };\n}\n\nexport function isAuthenticatedContext<T extends {}>(\n  context: T | undefined | null,\n): context is T & AuthenticatedContext {\n  return isNotNullOrUndefined(context) && context.hasOwnProperty('user');\n}\n\nexport interface LoggerContext {\n  logger: Logger;\n}\n\nexport function isLoggerContext<T extends {}>(\n  context: T | undefined | null,\n): context is T & LoggerContext {\n  return isNotNullOrUndefined(context) && context.hasOwnProperty('logger');\n}\n\nexport interface RequestIdContext {\n  requestId: string;\n}\n\nexport function isRequestIdContext<T extends {}>(\n  context: T | undefined | null,\n): context is T & RequestIdContext {\n  return isNotNullOrUndefined(context) && context.hasOwnProperty('requestId');\n}\n\nexport interface RouteContext {\n  route: {\n    path: string;\n    params: { [key: string]: string };\n  };\n}\n\nexport function isRouteContext<T extends {}>(\n  context: T | undefined | null,\n): context is T & RouteContext {\n  return isNotNullOrUndefined(context) && context.hasOwnProperty('route');\n}\n\nexport function isExecutionContext<T extends {}>(\n  context: T | undefined | null,\n): context is T & ExecutionContext {\n  // We need to use getPrototypeOf since is not on the object itself\n  // In future we should wrap execution context as a member of context\n  // Like the other contexts\n  return (\n    isNotNullOrUndefined(context) &&\n    (Object.getPrototypeOf(context).hasOwnProperty('waitUntil') ||\n      context.hasOwnProperty('waitUntil'))\n  );\n}\n\nexport interface ProtoBufContext<TYPE extends {} | null> {\n  proto: {\n    body: TYPE;\n    requestType: MessageType<any> | null;\n    responseType: MessageType<any>;\n    responseFormat: MessageFormat;\n    requestFormat: MessageFormat;\n  };\n}\n\nexport function isProtoBufContext<T extends {}>(\n  context: T | undefined | null,\n): context is T & ProtoBufContext<{}> {\n  return isNotNullOrUndefined(context) && context.hasOwnProperty('proto');\n}\n", "import { MessageType } from '@protobuf-ts/runtime';\nimport { BasicError } from '../contracts/errors/v1/errors';\nimport { isNullOrUndefined } from './lib';\n\nexport function responseContainsBasicError(\n  responseType: MessageType<{}>,\n): boolean {\n  const errorType = responseType.fields.find((field) => field.name === 'error');\n  if (isNullOrUndefined(errorType) || errorType.kind !== 'message') {\n    return false;\n  }\n  return errorType.T() === BasicError;\n}\n", "import { MessageType } from '@protobuf-ts/runtime';\nimport { BasicError } from '../../contracts/errors/v1/errors';\nimport { isProtoBufContext } from '../middleware/context';\nimport { responseContainsBasicError } from '../protobuf-util';\nimport { MessageFormat, messageFormatToMediaType } from './types';\n\nexport function createProtoBufResponse(\n  body: {},\n  context: {\n    proto: { responseFormat: MessageFormat; responseType: MessageType<{}> };\n  },\n): Response {\n  const protoContext = context.proto;\n  const serializedBody =\n    protoContext.responseFormat === MessageFormat.PROTOBUF\n      ? protoContext.responseType.toBinary(body)\n      : protoContext.responseType.toJsonString(body);\n  return _createRawResponse(serializedBody, protoContext.responseFormat);\n}\n\nexport function createBasicErrorResponse(basicError: BasicError, context: {}) {\n  if (\n    isProtoBufContext(context) &&\n    responseContainsBasicError(context.proto.responseType)\n  ) {\n    return createProtoBufResponse({ error: basicError }, context);\n  }\n  return _createRawResponse(\n    JSON.stringify({ error: BasicError.toJson(basicError) }),\n    MessageFormat.JSON,\n  );\n}\n\nfunction _createRawResponse(\n  body: string | Uint8Array,\n  contentType: MessageFormat,\n) {\n  return new Response(body, {\n    status: 200,\n    headers: {\n      'Content-Type': messageFormatToMediaType(contentType),\n      'Access-Control-Allow-Origin': '*',\n      'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',\n    },\n  });\n}\n", "import { MessageType } from '@protobuf-ts/runtime';\nimport {\n  BasicError,\n  BasicError_BasicErrorCode,\n} from '../../contracts/errors/v1/errors';\nimport { getRequestFormat, getResponseFormat } from '../http/request';\nimport {\n  createBasicErrorResponse,\n  createProtoBufResponse,\n} from '../http/response';\nimport { MessageFormat } from '../http/types';\nimport { isNotNullOrUndefined } from '../lib';\nimport { LoggerContext, ProtoBufContext } from './context';\n\nexport function createProtoBufOkResponse<TYPE>(data: TYPE): {\n  response: {\n    oneofKind: 'ok';\n    ok: TYPE;\n  };\n} {\n  return {\n    response: {\n      oneofKind: 'ok',\n      ok: data,\n    },\n  };\n}\n\nexport function createProtoBufBasicErrorResponse(\n  message: string,\n  code: BasicError_BasicErrorCode,\n): {\n  response: {\n    oneofKind: 'error';\n    error: BasicError;\n  };\n} {\n  return {\n    response: {\n      oneofKind: 'error',\n      error: {\n        message,\n        code,\n      },\n    },\n  };\n}\n\nasync function extractedRequestBody<REQUEST_BODY extends {}>(\n  requestFormat: MessageFormat,\n  request: Request,\n  requestType: MessageType<REQUEST_BODY>,\n) {\n  let requestBody;\n  if (requestFormat === MessageFormat.PROTOBUF) {\n    const buffer = await request.arrayBuffer();\n    const uint8Array = new Uint8Array(buffer);\n    requestBody = requestType.fromBinary(uint8Array);\n  } else {\n    requestBody = requestType.fromJson(await request.json());\n    if (!requestType.is(requestBody)) {\n      throw new Error(`Request body does not match schema. ${requestBody}`);\n    }\n  }\n  return requestBody;\n}\n\nexport function protoBuf<\n  REQUEST extends Request,\n  ENV extends {},\n  CONTEXT extends LoggerContext,\n  RESPONSE extends Response,\n  REQUEST_BODY extends {},\n  RESPONSE_BODY extends {},\n>(\n  requestType: MessageType<REQUEST_BODY> | null,\n  responseType: MessageType<RESPONSE_BODY>,\n  fn: (\n    request: REQUEST,\n    env: ENV,\n    context: CONTEXT & ProtoBufContext<REQUEST_BODY>,\n  ) => Promise<RESPONSE_BODY>,\n): (request: REQUEST, env: ENV, context: CONTEXT) => Promise<Response> {\n  return async (\n    request: REQUEST,\n    env: ENV,\n    context: CONTEXT,\n  ): Promise<Response> => {\n    let requestBody = null;\n    let responseFormat = getResponseFormat(request);\n    let requestFormat = getRequestFormat(request);\n    try {\n      if (isNotNullOrUndefined(requestType)) {\n        requestBody = await extractedRequestBody<REQUEST_BODY>(\n          requestFormat,\n          request,\n          requestType,\n        );\n      }\n    } catch (e) {\n      context.logger.error(`could not parse request body. error=${e}`);\n      const basicError: BasicError = {\n        message: 'Could not parse requestBody',\n        code: BasicError_BasicErrorCode.BAD_REQUEST,\n      };\n      return createProtoBufResponse(basicError, {\n        proto: {\n          responseFormat,\n          responseType,\n        },\n      });\n    }\n\n    const protobufContext: ProtoBufContext<REQUEST_BODY | null> = {\n      proto: {\n        body: requestBody,\n        responseType,\n        requestType,\n        responseFormat,\n        requestFormat,\n      },\n    };\n    const newContext = Object.assign(context, protobufContext) as CONTEXT &\n      ProtoBufContext<REQUEST_BODY>;\n\n    try {\n      const response = await fn(request, env, newContext);\n      return createProtoBufResponse(response, newContext);\n    } catch (e) {\n      context.logger.fatal(\n        `An unknown error occurred while handling the request. requestBody=${JSON.stringify(\n          requestBody,\n        )}`,\n        e,\n      );\n      const basicError: BasicError = {\n        message: 'An unknown error occurred',\n        code: BasicError_BasicErrorCode.UNKNOWN,\n      };\n      return createBasicErrorResponse(basicError, newContext);\n    }\n  };\n}\n", "import { BasicError_BasicErrorCode } from '../../contracts/errors/v1/errors';\nimport { createBasicErrorResponse } from '../http/response';\nimport { isNotNullOrUndefined } from '../lib';\nimport { LoggerContext, RouteContext } from './context';\n\ntype Method = 'GET' | 'POST' | 'DELETE';\n\ntype ParamConfig = {\n  paramName: string;\n};\n\ntype RouteFunction<REQUEST extends Request, ENV, CONTEXT, RESPONSE> = (\n  request: REQUEST,\n  env: ENV,\n  context: CONTEXT & RouteContext,\n) => Promise<RESPONSE>;\n\ninterface RouteConfig<ENV, CONTEXT, ROUTE_FUNCTION> {\n  method: Method;\n  path: Array<ParamConfig | string>;\n  fn: ROUTE_FUNCTION;\n}\n\nexport function route<\n  REQUEST extends Request,\n  ENV,\n  CONTEXT,\n  RESPONSE extends Response,\n>(\n  method: Method,\n  path: Array<ParamConfig | string>,\n  fn: RouteFunction<REQUEST, ENV, CONTEXT, RESPONSE>,\n): RouteConfig<ENV, CONTEXT, RouteFunction<REQUEST, ENV, CONTEXT, RESPONSE>> {\n  return {\n    method,\n    path,\n    fn,\n  };\n}\n\nexport function pathParam(paramName: string): ParamConfig {\n  return { paramName };\n}\n\nfunction checkRouteMatchAndParseContext(\n  routeSegments: Array<ParamConfig | string>,\n  urlSegments: string[],\n  path: string,\n): null | RouteContext {\n  if (routeSegments.length !== urlSegments.length) {\n    return null;\n  }\n  const params: { [key: string]: string } = {};\n  for (\n    let segmentIndex = 0;\n    segmentIndex < routeSegments.length;\n    segmentIndex++\n  ) {\n    const routeSegment = routeSegments[segmentIndex];\n    const urlSegment = urlSegments[segmentIndex];\n    if (typeof routeSegment === 'string') {\n      if (routeSegment !== urlSegment) {\n        return null;\n      }\n    } else {\n      params[routeSegment.paramName] = urlSegment;\n    }\n  }\n  return {\n    route: {\n      path,\n      params,\n    },\n  };\n}\n\nexport function addRouter<\n  REQUEST extends Request,\n  ENV,\n  CONTEXT extends LoggerContext,\n  RESPONSE extends Response,\n>(\n  routes: RouteConfig<\n    ENV,\n    CONTEXT,\n    RouteFunction<REQUEST, ENV, CONTEXT, RESPONSE>\n  >[],\n) {\n  return async (request: REQUEST, env: ENV, context: CONTEXT) => {\n    let pathname = new URL(request.url).pathname;\n    const urlSegments = pathname\n      .split('/')\n      .map((s) => s.trim())\n      .filter((s) => s.length > 0);\n    for (let routeIndex = 0; routeIndex < routes.length; routeIndex++) {\n      const route = routes[routeIndex];\n      if (route.method !== request.method) {\n        continue;\n      }\n      let routeContext = checkRouteMatchAndParseContext(\n        route.path,\n        urlSegments,\n        pathname,\n      );\n      if (isNotNullOrUndefined(routeContext)) {\n        context.logger.info(\n          `Handling request for method=${request.method} pathname=${pathname}`,\n        );\n        return await route.fn(\n          request,\n          env,\n          Object.assign(context, routeContext),\n        );\n      }\n    }\n    const notFoundErrorMessage = `No route found for method=${request.method} pathname=${pathname}`;\n    context.logger.info(notFoundErrorMessage);\n    return createBasicErrorResponse(\n      {\n        message: notFoundErrorMessage,\n        code: BasicError_BasicErrorCode.NOT_FOUND,\n      },\n      context,\n    );\n  };\n}\n", null, null, null, "import { formatErrorToString } from 'workers-loki-logger';\nimport { isNullOrUndefined } from './lib';\nimport { isLoggerContext } from './middleware/context';\n\nexport function logInfo(message: string, context: {}) {\n  if (isLoggerContext(context)) {\n    context.logger.info(message);\n  } else {\n    console.info(message);\n  }\n}\n\nexport function logError(message: string, context: {}): void;\nexport function logError(message: string, error: any, context: {}): void;\nexport function logError(message: string, param1: any | {}, param2?: {}) {\n  const { error, context } = isNullOrUndefined(param2)\n    ? { error: undefined, context: param1 }\n    : { error: param1, context: param2 };\n  if (isLoggerContext(context)) {\n    context.logger.error(message, error);\n  } else {\n    console.error(message + ' ' + formatErrorToString(error), error);\n  }\n}\n", "const CORS_HEADERS = {\n  'Access-Control-Allow-Origin': '*',\n  'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',\n  'Access-Control-Allow-Headers': 'Content-Type, Authorization',\n  'Access-Control-Max-Age': '3600',\n};\n\nexport function addCors<\n  REQUEST extends Request,\n  ENV,\n  CONTEXT,\n  RESPONSE extends Response,\n>(\n  fn: (request: REQUEST, env: ENV, context: CONTEXT) => Promise<RESPONSE>,\n): (request: REQUEST, env: ENV, context: CONTEXT) => Promise<Response> {\n  return async (\n    request: REQUEST,\n    env: ENV,\n    context: CONTEXT,\n  ): Promise<Response> => {\n    if (request.method === 'OPTIONS') {\n      return new Response(null, {\n        status: 200,\n        headers: CORS_HEADERS,\n      });\n    }\n    return await fn(request, env, context);\n  };\n}\n", "import { Logger } from 'workers-loki-logger';\nimport { logError } from '../logger';\nimport {\n  isAuthenticatedContext,\n  isRequestIdContext,\n  isRouteContext,\n  isTestingContext,\n  LoggerContext,\n} from './context';\n\nexport interface LoggerConfig {\n  LOKI_SECRET: string;\n  ENVIRONMENT: string;\n}\n\nfunction addLoggerToContext<CONTEXT extends {}>(\n  serviceName: string,\n  loggingConfig: LoggerConfig,\n  context: CONTEXT,\n): CONTEXT & LoggerContext {\n  const logger = new Logger({\n    lokiSecret: loggingConfig.LOKI_SECRET,\n    cloudflareContext: context,\n    stream: {\n      service: serviceName,\n      environment: loggingConfig.ENVIRONMENT,\n    },\n  });\n  return Object.assign(context, { logger });\n}\n\nfunction isString(type: any): type is string {\n  return typeof type === 'string';\n}\n\nexport function addLoggerContext<\n  ENV extends LoggerConfig,\n  REQUEST,\n  CONTEXT extends {},\n  RESPONSE,\n>(\n  serviceNameParam: string | (() => string),\n  fn: (\n    request: REQUEST,\n    env: ENV,\n    context: CONTEXT & LoggerContext,\n  ) => Promise<RESPONSE>,\n) {\n  return async (request: REQUEST, env: ENV, cfContext: CONTEXT) => {\n    const serviceName = isString(serviceNameParam)\n      ? serviceNameParam\n      : serviceNameParam();\n    const context = addLoggerToContext(serviceName, env, cfContext);\n    let response;\n    try {\n      response = await fn(request, env, context);\n    } catch (e) {\n      logError('Logger caught error handling request', e, context);\n      throw e;\n    } finally {\n      context.logger.mdcSet('serviceName', serviceName);\n      if (isRequestIdContext(context)) {\n        context.logger.mdcSet('requestId', context.requestId);\n      }\n      if (isAuthenticatedContext(context)) {\n        context.logger.mdcSet('userId', context.user.userId);\n      }\n      if (isRouteContext(context)) {\n        context.logger.mdcSet('path', context.route.path);\n      }\n      if (!isTestingContext(context)) {\n        await context.logger.flush();\n      }\n    }\n    return response;\n  };\n}\n\nexport function addLoggerContextToSchedule<ENV extends LoggerConfig>(\n  serviceName: string,\n  fn: (\n    event: ScheduledEvent,\n    env: ENV,\n    context: ExecutionContext & LoggerContext,\n  ) => Promise<void>,\n) {\n  return async (\n    event: ScheduledEvent,\n    env: ENV,\n    cfContext: ExecutionContext,\n  ) => {\n    const context = addLoggerToContext(serviceName, env, cfContext);\n    try {\n      await fn(event, env, context);\n    } catch (e) {\n      logError('Logger caught error handling request', e, context);\n    } finally {\n      context.logger.mdcSet('serviceName', serviceName);\n      if (isRequestIdContext(context)) {\n        context.logger.mdcSet('requestId', context.requestId);\n      }\n      if (isAuthenticatedContext(context)) {\n        context.logger.mdcSet('userId', context.user.userId);\n      }\n      if (isRouteContext(context)) {\n        context.logger.mdcSet('path', context.route.path);\n      }\n      await context.logger.flush();\n    }\n  };\n}\n", "export const requestIdHeader = 'X-Request-ID';\n", "import { requestIdHeader } from '../request-id-header';\nimport { RequestIdContext } from './context';\n\n// on-fetch\n// on-durable-object-fetch\nexport function addRequestId<\n  REQUEST extends Request,\n  ENV,\n  CONTEXT,\n  RESPONSE extends Response,\n>(\n  fn: (\n    request: REQUEST,\n    env: ENV,\n    context: CONTEXT & RequestIdContext,\n  ) => Promise<RESPONSE>,\n) {\n  return async (request: REQUEST, env: ENV, cfContext: CONTEXT) => {\n    const requestId =\n      request.headers.get(requestIdHeader) ?? crypto.randomUUID();\n    const response = await fn(\n      request,\n      env,\n      Object.assign(cfContext, { requestId }),\n    );\n    response.headers.set(requestIdHeader, requestId);\n    return response;\n  };\n}\n", "import {BasicError_BasicErrorCode} from '../../contracts/errors/v1/errors';\nimport {createBasicErrorResponse} from '../http/response';\nimport {logError} from '../logger';\nimport {LoggerContext, RequestIdContext} from '../middleware/context';\nimport {addCors} from '../middleware/cors-middleware';\nimport {addLoggerContext} from '../middleware/logger-middleware';\nimport {addRequestId} from '../middleware/request-id-middleware';\n\nexport function onFetch<ENV extends {\n  LOKI_SECRET: string;\n  ENVIRONMENT: string;\n},\n  >(\n  serviceName: string,\n  fn: (\n    request: Request,\n    env: ENV,\n    context: ExecutionContext & RequestIdContext & LoggerContext,\n  ) => Promise<Response>,\n  initialContextGetter?: (request: Request, env: ENV, context: ExecutionContext) => Promise<Response>,\n) {\n  const packedFn = initialContextGetter ?? addCors(addRequestId(addLoggerContext(serviceName, fn)));\n  return async (request: Request, env: ENV, context: ExecutionContext) => {\n    try {\n      return await packedFn(request, env, context);\n    } catch (e) {\n      logError('Error handling request', e, context);\n      return createBasicErrorResponse(\n        {\n          message: 'Error handling request',\n          code: BasicError_BasicErrorCode.UNKNOWN,\n        },\n        context,\n      );\n    }\n  };\n}\n", "import {\n  GetPingRequest,\n  GetPingResponse,\n  Ping,\n} from '../../contracts/pings/v1/pings';\nimport {\n  createProtoBufOkResponse,\n  protoBuf,\n} from '../../lib/middleware/protobuf-middleware';\nimport { addRouter, route } from '../../lib/middleware/router-middleware';\nimport { onFetch } from '../../lib/starter/on-fetch';\n\ntype Environment = {\n  LOKI_SECRET: string;\n  ENVIRONMENT: string;\n};\n\n// noinspection JSUnusedGlobalSymbols\nexport default {\n  fetch: onFetch<Environment>(\n    'ping',\n    addRouter([\n      route(\n        'POST',\n        ['v1', 'get-ping'],\n        protoBuf(\n          GetPingRequest,\n          GetPingResponse,\n          async (request, env, context) => {\n            let pingId = context.proto.body.pingId;\n\n            context.logger.info(`received ping with pingId=${pingId}`);\n            return createProtoBufOkResponse<Ping>({\n              pingId: pingId,\n              message: 'pong',\n            });\n          },\n        ),\n      ),\n    ]),\n  ),\n};\n"],
  "mappings": "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",
  "names": []
}
